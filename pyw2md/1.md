# ä»£ç è½¬Markdownæ–‡æ¡£

**ç”Ÿæˆæ—¶é—´:** 2025-10-14 19:07:50
**æ–‡ä»¶æ•°é‡:** 19
**æ€»å¤§å°:** 79.2 KB
**ç¼–ç¨‹è¯­è¨€:** JSON, Python
**ä½¿ç”¨æ¨¡æ¿:** é»˜è®¤

---

# config.json

```json
{
  "window": {
    "width": 1280,
    "height": 800,
    "min_width": 1000,
    "min_height": 600
  },
  "template": "é»˜è®¤",
  "recent_files": [],
  "max_recent_files": 50,
  "auto_save_config": true,
  "preview_max_files": 5,
  "auto_watch_files": true,
  "watch_debounce_time": 1.0
}
# main.py

```python
"""
ä»£ç è½¬Markdownå·¥å…·
"""

import customtkinter as ctk
from ui.app import MaterialApp

def main():
    """åº”ç”¨å…¥å£"""
    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("blue")

    app = MaterialApp()
    app.mainloop()

if __name__ == "__main__":
    main()

# config\settings.py

```python
"""
åº”ç”¨é…ç½®ç®¡ç†
"""

import json
import os
from typing import Dict, Any

class Settings:
    """é…ç½®ç®¡ç†å™¨"""

    def __init__(self, config_file: str = "config.json"):
        self.config_file = config_file
        self.config: Dict[str, Any] = {}
        self.load()

    def load(self):
        """åŠ è½½é…ç½®"""
        if not os.path.exists(self.config_file):
            self.config = self._default_config()
            self.save()
            return

        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                self.config = json.load(f)
        except Exception as e:
            print(f"åŠ è½½é…ç½®å¤±è´¥: {e}")
            self.config = self._default_config()

    def save(self):
        """ä¿å­˜é…ç½®"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"ä¿å­˜é…ç½®å¤±è´¥: {e}")

    def get(self, key: str, default=None):
        """è·å–é…ç½®é¡¹"""
        return self.config.get(key, default)

    def set(self, key: str, value: Any):
        """è®¾ç½®é…ç½®é¡¹"""
        self.config[key] = value

    def _default_config(self) -> Dict[str, Any]:
        """é»˜è®¤é…ç½®"""
        return {
            "window": {
                "width": 1280,
                "height": 800,
                "min_width": 1000,
                "min_height": 600
            },
            "template": "é»˜è®¤",
            "recent_files": [],
            "max_recent_files": 50,
            "auto_save_config": True,
            "preview_max_files": 5,
            "auto_watch_files": True,  # æ–°å¢ï¼šè‡ªåŠ¨ç›‘æ§æ–‡ä»¶å˜åŒ–
            "watch_debounce_time": 1.0  # æ–°å¢ï¼šç›‘æ§é˜²æŠ–æ—¶é—´ï¼ˆç§’ï¼‰
        }

# config\theme.py

```python
"""
ç®€åŒ–ä¸»é¢˜ - Catppuccin Mochaå¯å‘
å®ç”¨ä¸»é¢˜ - é«˜å¯¹æ¯”åº¦æ·±è‰²
"""

class MD:
    # èƒŒæ™¯ï¼ˆ3çº§è¶³å¤Ÿï¼‰- æ·»åŠ å‘åå…¼å®¹åˆ«å
    BG_MAIN = "#1E1E2E"      # ä¸»èƒŒæ™¯
    BG_SURFACE = "#2A2A3A"   # å¡ç‰‡
    BG_ELEVATED = "#363650"  # é«˜äº®/æ‚¬åœ
    BACKGROUND = "#1E1E2E"   # å‘åå…¼å®¹

    # æ–‡å­—ï¼ˆ2çº§è¶³å¤Ÿï¼‰
    TEXT_PRIMARY = "#CDD6F4"   # ä¸»æ–‡å­—
    TEXT_SECONDARY = "#BAC2DE" # æ¬¡è¦æ–‡å­—

    # å¼ºè°ƒè‰²ï¼ˆ3ä¸ªè¶³å¤Ÿï¼‰
    ACCENT_BLUE = "#89B4FA"    # ä¸»æ“ä½œ
    ACCENT_GREEN = "#A6E3A1"   # æˆåŠŸ
    ACCENT_RED = "#F38BA8"     # é”™è¯¯/å±é™©
    ACCENT_YELLOW = "#F9E2AF"  # è­¦å‘Š

    # åˆ«åï¼ˆå‘åå…¼å®¹ï¼‰
    PRIMARY = "#89B4FA"        # ä¸»è‰²
    SUCCESS = "#A6E3A1"        # æˆåŠŸè‰²
    ERROR = "#F38BA8"          # é”™è¯¯è‰²

    # è¾¹æ¡†
    BORDER = "#45475A"

    # é—´è·ï¼ˆ2ä¸ªè¶³å¤Ÿï¼‰
    PAD_S = 8
    PAD_M = 12

    # åœ†è§’ï¼ˆ1ä¸ªè¶³å¤Ÿï¼‰
    RADIUS = 4

    # å­—ä½“
    FONT_MONO = ("Cascadia Code", 9)  # æ›´ç°ä»£çš„ç­‰å®½å­—ä½“
    FONT_UI = ("Segoe UI", 9)
    FONT_TITLE = ("Segoe UI Semibold", 10)

    # Material Design å‘åå…¼å®¹æ€§ - æ·»åŠ ç¼ºå¤±çš„é¢œè‰²å¸¸é‡
    ON_SURFACE = "#CDD6F4"      # è¡¨é¢æ–‡å­—è‰²
    ON_SURFACE_VARIANT = "#BAC2DE"  # è¡¨é¢å˜ä½“æ–‡å­—è‰²
    ON_PRIMARY = "#FFFFFF"      # ä¸»è‰²æ–‡å­—
    SURFACE = "#2A2A3A"         # è¡¨é¢ï¼ˆé€šç”¨ï¼‰
    SURFACE_1 = "#2A2A3A"       # è¡¨é¢1
    SURFACE_2 = "#363650"       # è¡¨é¢2
    FONT_HEADLINE = ("Segoe UI Semibold", 12)  # æ ‡é¢˜å­—ä½“
    FONT_BODY = ("Segoe UI", 10)    # æ­£æ–‡å­—ä½“
    FONT_LABEL = ("Segoe UI", 9)    # æ ‡ç­¾å­—ä½“
    FONT_MONO = ("Cascadia Code", 9)  # ç­‰å®½å­—ä½“

    # è­¦å‘Šé¢œè‰²
    WARNING = "#FAB387"         # è­¦å‘Šè‰²
    WARNING_CONTAINER = "#7C2D12"  # è­¦å‘Šå®¹å™¨

    # ä¸»è‰²å®¹å™¨
    PRIMARY_CONTAINER = "#1E40AF"   # ä¸»è‰²å®¹å™¨

    # è½®å»“è‰²
    OUTLINE = "#797979"         # è½®å»“è‰²

    # ä¿¡æ¯è‰²
    INFO = "#74C7EC"            # ä¿¡æ¯è‰²

    # åœ†è§’å¤§å°
    RADIUS_MEDIUM = 8           # ä¸­ç­‰åœ†è§’

    # é—´è·å¸¸é‡ï¼ˆå‘åå…¼å®¹ï¼‰
    SPACING_XS = 4              # æå°é—´è·

# å¿«æ·è®¿é—®ä¿æŒä¸å˜
MD = MD

# config\__init__.py

```python

# core\converter.py

```python
"""
Markdown è½¬æ¢æ ¸å¿ƒæ¨¡å— - æ€§èƒ½ä¼˜åŒ–ç‰ˆ
"""

import os
import time
from typing import Callable, Optional
from io import StringIO
from concurrent.futures import ThreadPoolExecutor, as_completed
from core.file_handler import FileInfo

# Markdown æ¨¡æ¿ï¼ˆä¿æŒä¸å˜ï¼‰
TEMPLATES = {
    "é»˜è®¤": """# {relative_path}

```{language}
{content}
""",

"è¯¦ç»†ä¿¡æ¯": """## {basename}
è·¯å¾„: {relative_path}
è¯­è¨€: {language}
å¤§å°: {size}
ä¿®æ”¹æ—¶é—´: {mtime}

{content}
""",

"GitHub é£æ ¼": """## {basename}

{content}
<details> <summary>æ–‡ä»¶ä¿¡æ¯</summary>
å®Œæ•´è·¯å¾„: {relative_path}
ç¼–ç¨‹è¯­è¨€: {language}
æ–‡ä»¶å¤§å°: {size}
æœ€åä¿®æ”¹: {mtime}
</details>
""",

"ç®€æ´æ¨¡å¼": """```{language}
// {relative_path}
{content}


""",
    
    "å¸¦ç›®å½•": """### {relative_path}

<details open>
<summary>ç‚¹å‡»å±•å¼€/æŠ˜å </summary>

```{language}
{content}
</details>
""",

"ä¸“ä¸šæ–‡æ¡£": """## {basename}
è·¯å¾„: {relative_path}
è¯­è¨€: {language}
å¤§å°: {size}

{content}
æœ€åä¿®æ”¹: {mtime}

"""
}

class Converter:
    """Markdown è½¬æ¢å™¨ - æ€§èƒ½ä¼˜åŒ–ç‰ˆ"""

    def __init__(self, template: str = "é»˜è®¤", max_workers: int = 4):
        self.template = template
        self.base_path = os.getcwd()
        self.max_workers = max_workers  # çº¿ç¨‹æ± å¤§å°
        self.chunk_size = 50  # æ‰¹é‡å†™å…¥æ–‡ä»¶æ•°

    def set_template(self, template: str):
        """è®¾ç½®æ¨¡æ¿"""
        if template in TEMPLATES:
            self.template = template

    def set_base_path(self, path: str):
        """è®¾ç½®åŸºå‡†è·¯å¾„"""
        self.base_path = path

    def convert_file(self, file_info: FileInfo) -> str:
            """è½¬æ¢å•ä¸ªæ–‡ä»¶ - ä¼˜åŒ–å­—ç¬¦ä¸²æ‹¼æ¥"""
            try:
                # è¯»å–æ–‡ä»¶å†…å®¹ï¼ˆä½¿ç”¨ with è‡ªåŠ¨å…³é—­ï¼‰
                with open(file_info.path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # å‡†å¤‡æ¨¡æ¿å˜é‡
                basename = os.path.basename(file_info.path)

                try:
                    relative_path = os.path.relpath(file_info.path, self.base_path)
                except ValueError:
                    relative_path = file_info.path

                mtime = time.strftime(
                    "%Y-%m-%d %H:%M:%S",
                    time.localtime(os.path.getmtime(file_info.path))
                )

                from core.file_handler import format_size
                size = format_size(file_info.size)

                # åº”ç”¨æ¨¡æ¿
                template = TEMPLATES.get(self.template, TEMPLATES["é»˜è®¤"])

                return template.format(
                    basename=basename,
                    relative_path=relative_path,
                    language=file_info.language.lower(),
                    size=size,
                    mtime=mtime,
                    content=content
                )

            except Exception as e:
                return f"<!-- âŒ é”™è¯¯: æ— æ³•å¤„ç†æ–‡ä»¶ {file_info.path}: {str(e)} -->\n\n"

    def convert_files(self,
                     files: list[FileInfo],
                     output_path: str,
                     progress_callback: Optional[Callable[[int, int, str], None]] = None) -> dict:
        """
        æ‰¹é‡è½¬æ¢æ–‡ä»¶ - æ€§èƒ½ä¼˜åŒ–ç‰ˆ

        ä¼˜åŒ–ç‚¹ï¼š
        1. ä½¿ç”¨çº¿ç¨‹æ± å¹¶è¡Œè¯»å–æ–‡ä»¶
        2. ä½¿ç”¨ StringIO ä¼˜åŒ–å­—ç¬¦ä¸²æ‹¼æ¥
        3. åˆ†æ‰¹å†™å…¥ç£ç›˜å‡å°‘IOæ¬¡æ•°

        Args:
            files: æ–‡ä»¶åˆ—è¡¨
            output_path: è¾“å‡ºæ–‡ä»¶è·¯å¾„
            progress_callback: è¿›åº¦å›è°ƒå‡½æ•° (current, total, filename)

        Returns:
            dict: è½¬æ¢ç»“æœç»Ÿè®¡
        """
        total = len(files)
        success = 0
        errors = []

        try:
            with open(output_path, 'w', encoding='utf-8', buffering=8192*16) as f:
                # å†™å…¥æ–‡æ¡£å¤´éƒ¨
                f.write(self._generate_header(files))

                # ä½¿ç”¨ StringIO ç¼“å†²åŒºä¼˜åŒ–å­—ç¬¦ä¸²æ‹¼æ¥
                buffer = StringIO()
                buffer_count = 0

                # ä½¿ç”¨çº¿ç¨‹æ± å¹¶è¡Œè½¬æ¢
                with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                    # æäº¤æ‰€æœ‰ä»»åŠ¡
                    future_to_file = {
                        executor.submit(self.convert_file, file_info): (i, file_info)
                        for i, file_info in enumerate(files, 1)
                    }

                    # æŒ‰å®Œæˆé¡ºåºå¤„ç†ï¼ˆä¿æŒæ–‡ä»¶é¡ºåºéœ€è¦æ’åºï¼‰
                    results = {}
                    for future in as_completed(future_to_file):
                        i, file_info = future_to_file[future]

                        try:
                            markdown = future.result()
                            results[i] = markdown
                            success += 1
                        except Exception as e:
                            errors.append({
                                'file': file_info.path,
                                'error': str(e)
                            })
                            results[i] = f"<!-- âŒ é”™è¯¯: {str(e)} -->\n\n"

                    # æŒ‰é¡ºåºå†™å…¥ç»“æœï¼ˆä½¿ç”¨ç¼“å†²åŒºï¼‰
                    for i in range(1, total + 1):
                        if i in results:
                            # å›è°ƒè¿›åº¦
                            if progress_callback:
                                progress_callback(i, total, files[i-1].name)

                            # å†™å…¥ç¼“å†²åŒº
                            buffer.write(results[i])
                            buffer_count += 1

                            # æ‰¹é‡å†™å…¥ç£ç›˜
                            if buffer_count >= self.chunk_size:
                                f.write(buffer.getvalue())
                                buffer.close()
                                buffer = StringIO()
                                buffer_count = 0

                    # å†™å…¥å‰©ä½™ç¼“å†²åŒº
                    if buffer_count > 0:
                        f.write(buffer.getvalue())
                        buffer.close()

                # å†™å…¥æ–‡æ¡£å°¾éƒ¨
                f.write(self._generate_footer(success, total))

        except Exception as e:
            return {
                'success': False,
                'message': f'å†™å…¥è¾“å‡ºæ–‡ä»¶å¤±è´¥: {str(e)}',
                'converted': 0,
                'total': total,
                'errors': errors
            }

        return {
            'success': True,
            'message': f'æˆåŠŸè½¬æ¢ {success}/{total} ä¸ªæ–‡ä»¶',
            'converted': success,
            'total': total,
            'errors': errors
        }

    def _generate_header(self, files: list[FileInfo]) -> str:
        """ç”Ÿæˆæ–‡æ¡£å¤´éƒ¨ - ä½¿ç”¨ join ä¼˜åŒ–"""
        from core.file_handler import format_size

        total_size = sum(f.size for f in files)
        languages = set(f.language for f in files)

        # ä½¿ç”¨åˆ—è¡¨å’Œ join ä¼˜åŒ–å­—ç¬¦ä¸²æ‹¼æ¥
        header_parts = [
            "# ä»£ç è½¬Markdownæ–‡æ¡£\n\n",
            f"**ç”Ÿæˆæ—¶é—´:** {time.strftime('%Y-%m-%d %H:%M:%S')}\n",
            f"**æ–‡ä»¶æ•°é‡:** {len(files)}\n",
            f"**æ€»å¤§å°:** {format_size(total_size)}\n",
            f"**ç¼–ç¨‹è¯­è¨€:** {', '.join(sorted(languages))}\n",
            f"**ä½¿ç”¨æ¨¡æ¿:** {self.template}\n\n",
            "---\n\n"
        ]

        return ''.join(header_parts)

    def _generate_footer(self, success: int, total: int) -> str:
        """ç”Ÿæˆæ–‡æ¡£å°¾éƒ¨ - ä½¿ç”¨ join ä¼˜åŒ–"""
        footer_parts = [
            "\n\n---\n\n",
            "## è½¬æ¢ç»Ÿè®¡\n\n",
            f"- æˆåŠŸè½¬æ¢: **{success}** ä¸ªæ–‡ä»¶\n",
            f"- æ€»è®¡å¤„ç†: **{total}** ä¸ªæ–‡ä»¶\n",
            f"- å®Œæˆæ—¶é—´: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n",
            "---\n\n",
            "æ–‡æ¡£ç”Ÿæˆå®Œæˆ\n"
        ]

        return ''.join(footer_parts)
def get_template_names() -> list[str]:
    """è·å–æ‰€æœ‰æ¨¡æ¿åç§°"""
    return list(TEMPLATES.keys())

def preview_template(template_name: str) -> str:
    """é¢„è§ˆæ¨¡æ¿å†…å®¹"""
    return TEMPLATES.get(template_name, TEMPLATES["é»˜è®¤"])
# core\file_handler.py

```python
"""
æ–‡ä»¶å¤„ç†æ ¸å¿ƒæ¨¡å—
"""

import os
from typing import List, Dict, Optional
from dataclasses import dataclass

# æ”¯æŒçš„è¯­è¨€å’Œæ‰©å±•å
LANGUAGE_EXTENSIONS = {
    'Python': ['.py', '.pyw', '.pyi'],
    'JavaScript': ['.js', '.jsx', '.mjs'],
    'TypeScript': ['.ts', '.tsx'],
    'Java': ['.java'],
    'C': ['.c', '.h'],
    'C++': ['.cpp', '.hpp', '.cc', '.cxx'],
    'C#': ['.cs'],
    'PHP': ['.php'],
    'Ruby': ['.rb'],
    'Go': ['.go'],
    'Rust': ['.rs'],
    'Swift': ['.swift'],
    'Kotlin': ['.kt', '.kts'],
    'HTML': ['.html', '.htm'],
    'CSS': ['.css', '.scss', '.sass', '.less'],
    'SQL': ['.sql'],
    'Shell': ['.sh', '.bash', '.zsh'],
    'PowerShell': ['.ps1'],
    'YAML': ['.yml', '.yaml'],
    'JSON': ['.json'],
    'XML': ['.xml'],
    'Markdown': ['.md'],
    'Vue': ['.vue'],
    'Svelte': ['.svelte'],
    'Dart': ['.dart'],
    'R': ['.r', '.R'],
    'Lua': ['.lua'],
    'Perl': ['.pl', '.pm'],
    'Text': ['.txt']
}

@dataclass
class FileInfo:
    """æ–‡ä»¶ä¿¡æ¯æ•°æ®ç±»"""
    path: str
    marked: bool = True
    _cached_size: int = None
    _cached_mtime: float = None
    
    @property
    def name(self) -> str:
        return os.path.basename(self.path)
    
    @property
    def language(self) -> str:
        return get_language(self.path)
    
    @property
    def size(self) -> int:
        try:
            return os.path.getsize(self.path)
        except:
            return 0
    
    @property
    def exists(self) -> bool:
        return os.path.exists(self.path)
    
    @property
    def mtime(self) -> float:
        """è·å–æ–‡ä»¶ä¿®æ”¹æ—¶é—´"""
        try:
            return os.path.getmtime(self.path)
        except:
            return 0
    
    def is_modified(self) -> bool:
        """æ£€æŸ¥æ–‡ä»¶æ˜¯å¦è¢«ä¿®æ”¹"""
        if self._cached_mtime is None:
            self._cached_mtime = self.mtime
            return False
        return self.mtime != self._cached_mtime
    
    def update_cache(self):
        """æ›´æ–°ç¼“å­˜ä¿¡æ¯"""
        self._cached_size = self.size
        self._cached_mtime = self.mtime

class FileHandler:
    """æ–‡ä»¶å¤„ç†å™¨"""
    
    def __init__(self):
        self.files: List[FileInfo] = []
    
    def add_file(self, path: str) -> bool:
        """æ·»åŠ å•ä¸ªæ–‡ä»¶"""
        if not os.path.isfile(path):
            return False
        
        # æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
        if any(f.path == path for f in self.files):
            return False
        
        file_info = FileInfo(path=path, marked=True)
        file_info.update_cache()
        self.files.append(file_info)
        return True
    
    def add_files(self, paths: List[str]) -> int:
        """æ‰¹é‡æ·»åŠ æ–‡ä»¶"""
        count = 0
        for path in paths:
            if self.add_file(path):
                count += 1
        return count
    
    def add_folder(self, folder_path: str, recursive: bool = True) -> int:
        """æ·»åŠ æ–‡ä»¶å¤¹ä¸­çš„æ‰€æœ‰æ”¯æŒæ–‡ä»¶"""
        if not os.path.isdir(folder_path):
            return 0
        
        files = scan_folder(folder_path, recursive)
        return self.add_files(files)
    
    def remove_file(self, path: str) -> bool:
        """ç§»é™¤æ–‡ä»¶"""
        for i, file in enumerate(self.files):
            if file.path == path:
                self.files.pop(i)
                return True
        return False
    
    def clear(self):
        """æ¸…ç©ºæ‰€æœ‰æ–‡ä»¶"""
        self.files.clear()
    
    def toggle_mark(self, path: str) -> bool:
        """åˆ‡æ¢æ–‡ä»¶æ ‡è®°çŠ¶æ€"""
        for file in self.files:
            if file.path == path:
                file.marked = not file.marked
                return file.marked
        return False
    
    def mark_all(self, marked: bool = True):
        """æ ‡è®°/å–æ¶ˆæ ‡è®°æ‰€æœ‰æ–‡ä»¶"""
        for file in self.files:
            file.marked = marked
    
    def get_marked_files(self) -> List[FileInfo]:
        """è·å–æ‰€æœ‰å·²æ ‡è®°çš„æ–‡ä»¶"""
        return [f for f in self.files if f.marked]
    
    def get_stats(self) -> Dict:
        """è·å–ç»Ÿè®¡ä¿¡æ¯"""
        total = len(self.files)
        marked = len(self.get_marked_files())
        total_size = sum(f.size for f in self.files)
        languages = set(f.language for f in self.files)
        
        return {
            'total': total,
            'marked': marked,
            'size': total_size,
            'languages': len(languages)
        }
    
    def filter_files(self, 
                    search: Optional[str] = None,
                    language: Optional[str] = None) -> List[FileInfo]:
        """ç­›é€‰æ–‡ä»¶"""
        result = self.files
        
        if search:
            search = search.lower()
            result = [f for f in result if search in f.name.lower()]
        
        if language and language != "å…¨éƒ¨è¯­è¨€":
            result = [f for f in result if f.language == language]
        
        return result
    
    def refresh_files(self) -> Dict:
        """åˆ·æ–°æ‰€æœ‰æ–‡ä»¶ï¼Œç§»é™¤ä¸å­˜åœ¨çš„ï¼Œæ›´æ–°ç¼“å­˜"""
        removed = []
        modified = []
        
        # æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨ï¼Œæ˜¯å¦è¢«ä¿®æ”¹
        for file_info in self.files[:]:  # ä½¿ç”¨åˆ‡ç‰‡åˆ›å»ºå‰¯æœ¬è¿›è¡Œè¿­ä»£
            if not file_info.exists:
                self.files.remove(file_info)
                removed.append(file_info.path)
            else:
                if file_info.is_modified():
                    modified.append(file_info.path)
                file_info.update_cache()
        
        return {
            'removed': removed,
            'modified': modified,
            'removed_count': len(removed),
            'modified_count': len(modified)
        }

def get_language(file_path: str) -> str:
    """æ ¹æ®æ–‡ä»¶æ‰©å±•åè·å–ç¼–ç¨‹è¯­è¨€"""
    _, ext = os.path.splitext(file_path.lower())
    
    for language, extensions in LANGUAGE_EXTENSIONS.items():
        if ext in extensions:
            return language
    
    return "Text"

def get_all_languages() -> List[str]:
    """è·å–æ‰€æœ‰æ”¯æŒçš„è¯­è¨€"""
    return sorted(LANGUAGE_EXTENSIONS.keys())

def scan_folder(folder_path: str, recursive: bool = True) -> List[str]:
    """æ‰«ææ–‡ä»¶å¤¹è·å–æ‰€æœ‰æ”¯æŒçš„æ–‡ä»¶"""
    supported_files = []
    all_extensions = [ext for exts in LANGUAGE_EXTENSIONS.values() for ext in exts]
    
    if recursive:
        for root, _, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                _, ext = os.path.splitext(file_path.lower())
                if ext in all_extensions:
                    supported_files.append(file_path)
    else:
        for file in os.listdir(folder_path):
            file_path = os.path.join(folder_path, file)
            if os.path.isfile(file_path):
                _, ext = os.path.splitext(file_path.lower())
                if ext in all_extensions:
                    supported_files.append(file_path)
    
    return supported_files

def format_size(size_bytes: int) -> str:
    """æ ¼å¼åŒ–æ–‡ä»¶å¤§å°"""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024):.1f} MB"
    else:
        return f"{size_bytes / (1024 * 1024 * 1024):.1f} GB"
# core\file_watcher.py

```python
"""
æ–‡ä»¶ç›‘æ§æ¨¡å— - è‡ªåŠ¨æ£€æµ‹æ–‡ä»¶å˜åŒ–
"""

import os
import time
from typing import Callable, Dict, Set
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileModifiedEvent, FileDeletedEvent
from threading import Lock

class FileChangeHandler(FileSystemEventHandler):
    """æ–‡ä»¶å˜åŒ–å¤„ç†å™¨"""
    
    def __init__(self, callback: Callable, watched_files: Set[str]):
        super().__init__()
        self.callback = callback
        self.watched_files = watched_files
        self.last_modified = {}
        self.lock = Lock()
        
        # é˜²æŠ–æ—¶é—´ï¼ˆç§’ï¼‰
        self.debounce_time = 1.0
    
    def on_modified(self, event):
        """æ–‡ä»¶è¢«ä¿®æ”¹"""
        if event.is_directory:
            return
        
        file_path = os.path.abspath(event.src_path)
        
        # åªå¤„ç†ç›‘æ§åˆ—è¡¨ä¸­çš„æ–‡ä»¶
        if file_path not in self.watched_files:
            return
        
        # é˜²æŠ–å¤„ç†
        with self.lock:
            current_time = time.time()
            last_time = self.last_modified.get(file_path, 0)
            
            if current_time - last_time < self.debounce_time:
                return
            
            self.last_modified[file_path] = current_time
        
        # å›è°ƒé€šçŸ¥
        self.callback('modified', file_path)
    
    def on_deleted(self, event):
        """æ–‡ä»¶è¢«åˆ é™¤"""
        if event.is_directory:
            return
        
        file_path = os.path.abspath(event.src_path)
        
        if file_path not in self.watched_files:
            return
        
        self.callback('deleted', file_path)

class FileWatcher:
    """æ–‡ä»¶ç›‘æ§å™¨"""
    
    def __init__(self, callback: Callable):
        """
        åˆå§‹åŒ–æ–‡ä»¶ç›‘æ§å™¨
        
        Args:
            callback: å›è°ƒå‡½æ•° callback(event_type, file_path)
                     event_type: 'modified' æˆ– 'deleted'
        """
        self.callback = callback
        self.observer = Observer()
        self.watched_files: Set[str] = set()
        self.watched_dirs: Dict[str, Set[str]] = {}  # ç›®å½• -> è¯¥ç›®å½•ä¸‹ç›‘æ§çš„æ–‡ä»¶é›†åˆ
        self.handler = None
        self.is_running = False
    
    def start(self):
        """å¯åŠ¨ç›‘æ§"""
        if not self.is_running:
            self.handler = FileChangeHandler(self.callback, self.watched_files)
            self.observer.start()
            self.is_running = True
    
    def stop(self):
        """åœæ­¢ç›‘æ§"""
        if self.is_running:
            self.observer.stop()
            self.observer.join(timeout=2)
            self.is_running = False
    
    def add_file(self, file_path: str):
        """æ·»åŠ æ–‡ä»¶åˆ°ç›‘æ§åˆ—è¡¨"""
        if not os.path.exists(file_path):
            return False
        
        file_path = os.path.abspath(file_path)
        dir_path = os.path.dirname(file_path)
        
        # æ·»åŠ åˆ°ç›‘æ§æ–‡ä»¶é›†åˆ
        self.watched_files.add(file_path)
        
        # å¦‚æœè¯¥ç›®å½•è¿˜æ²¡æœ‰è¢«ç›‘æ§ï¼Œæ·»åŠ ç›‘æ§
        if dir_path not in self.watched_dirs:
            self.watched_dirs[dir_path] = set()
            # ç¡®ä¿ handler å·²åˆå§‹åŒ–
            if self.handler is None:
                self.handler = FileChangeHandler(self.callback, self.watched_files)
            try:
                self.observer.schedule(self.handler, dir_path, recursive=False)
            except Exception as e:
                print(f"ç›‘æ§ç›®å½•å¤±è´¥ {dir_path}: {e}")
                return False
        
        # è®°å½•è¯¥ç›®å½•ä¸‹çš„æ–‡ä»¶
        self.watched_dirs[dir_path].add(file_path)
        return True
    
    def remove_file(self, file_path: str):
        """ä»ç›‘æ§åˆ—è¡¨ç§»é™¤æ–‡ä»¶"""
        file_path = os.path.abspath(file_path)
        dir_path = os.path.dirname(file_path)
        
        # ä»ç›‘æ§æ–‡ä»¶é›†åˆç§»é™¤
        self.watched_files.discard(file_path)
        
        # ä»ç›®å½•æ˜ å°„ä¸­ç§»é™¤
        if dir_path in self.watched_dirs:
            self.watched_dirs[dir_path].discard(file_path)
            
            # å¦‚æœè¯¥ç›®å½•ä¸‹æ²¡æœ‰å…¶ä»–ç›‘æ§æ–‡ä»¶äº†ï¼Œåœæ­¢ç›‘æ§è¯¥ç›®å½•
            if not self.watched_dirs[dir_path]:
                del self.watched_dirs[dir_path]
                # æ³¨æ„: watchdog ä¸æ”¯æŒç›´æ¥ç§»é™¤å•ä¸ªç›‘æ§ï¼Œéœ€è¦é‡å¯observer
    
    def clear(self):
        """æ¸…ç©ºæ‰€æœ‰ç›‘æ§"""
        self.watched_files.clear()
        self.watched_dirs.clear()
        
        if self.is_running:
            self.stop()
            self.observer = Observer()
            self.handler = FileChangeHandler(self.callback, self.watched_files)
            self.start()
    
    def get_watched_count(self) -> int:
        """è·å–ç›‘æ§æ–‡ä»¶æ•°é‡"""
        return len(self.watched_files)
# core\__init__.py

```python
# æ ¸å¿ƒåŠŸèƒ½åŒ…

# ui\app.py

```python
"""
ä¸»åº”ç”¨çª—å£ - ä¼˜åŒ–ç‰ˆï¼ˆæ‹–æ”¾é™çº§ + æ€§èƒ½ä¼˜åŒ–ï¼‰
"""

import customtkinter as ctk
from tkinter import filedialog, messagebox
import os

# å¯¼å…¥æ‹–æ”¾æ”¯æŒ
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    DRAG_DROP_AVAILABLE = True
except ImportError:
    DRAG_DROP_AVAILABLE = False
    print("æç¤º: å®‰è£… tkinterdnd2 ä»¥å¯ç”¨æ‹–æ”¾åŠŸèƒ½: pip install tkinterdnd2")

from config.theme import MD
from config.settings import Settings
from core.file_handler import FileHandler
from core.converter import Converter
from core.file_watcher import FileWatcher
from ui.components.file_list_panel import FileListPanel
from ui.components.control_panel import ControlPanel
from ui.components.dialogs import TemplatePreviewDialog, ConversionPreviewDialog


# ============ ä¼˜é›…é™çº§åŸºç±» ============
class DragDropMixin:
    """æ‹–æ”¾åŠŸèƒ½æ··åˆç±» - æä¾›å®‰å…¨çš„é™çº§å¤„ç†"""
    
    def drop_target_register(self, *args, **kwargs):
        """å®‰å…¨çš„æ‹–æ”¾æ³¨å†Œ"""
        if DRAG_DROP_AVAILABLE and hasattr(super(), 'drop_target_register'):
            return super().drop_target_register(*args, **kwargs)
        return None
    
    def dnd_bind(self, *args, **kwargs):
        """å®‰å…¨çš„æ‹–æ”¾ç»‘å®š"""
        if DRAG_DROP_AVAILABLE and hasattr(super(), 'dnd_bind'):
            return super().dnd_bind(*args, **kwargs)
        return None


if DRAG_DROP_AVAILABLE:
    class AppBase(DragDropMixin, TkinterDnD.Tk):
        """æ”¯æŒæ‹–æ”¾çš„åŸºç±»"""
        def __init__(self):
            TkinterDnD.Tk.__init__(self)
else:
    class AppBase(DragDropMixin, ctk.CTk):
        """ä¸æ”¯æŒæ‹–æ”¾çš„é™çº§åŸºç±»"""
        def __init__(self):
            ctk.CTk.__init__(self)


class MaterialApp(AppBase):
    """ä¸»åº”ç”¨ç¨‹åº - æ€§èƒ½ä¼˜åŒ–ç‰ˆ"""
    
    def __init__(self):
        super().__init__()
        
        # åˆå§‹åŒ–
        self.settings = Settings()
        self.file_handler = FileHandler()
        self.converter = Converter()
        
        # æ–‡ä»¶ç›‘æ§å™¨
        self.file_watcher = FileWatcher(self._on_file_changed)
        self.watch_enabled = self.settings.get('auto_watch_files', True)
        
        # ä¿®æ”¹æ–‡ä»¶è·Ÿè¸ª
        self.modified_files = set()
        self.deleted_files = set()
        
        # çª—å£è°ƒæ•´é˜²æŠ–
        self._resize_after_id = None
        
        self._setup_window()
        self._build_ui()
        self._setup_drag_drop()
        self._load_saved_state()
        
        # å¯åŠ¨æ–‡ä»¶ç›‘æ§
        if self.watch_enabled:
            self.file_watcher.start()
        
        # ç»‘å®šå…³é—­äº‹ä»¶
        self.protocol("WM_DELETE_WINDOW", self._on_closing)
        self.bind('<Configure>', self._on_window_configure)
    
    def _setup_window(self):
        """è®¾ç½®çª—å£"""
        self.title("ä»£ç è½¬Markdownå·¥å…· - æ€§èƒ½ä¼˜åŒ–ç‰ˆ")
        
        width = self.settings.get('window', {}).get('width', 1280)
        height = self.settings.get('window', {}).get('height', 800)
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x = (screen_width - width) // 2
        y = (screen_height - height) // 2
        
        self.geometry(f"{width}x{height}+{x}+{y}")
        
        min_width = self.settings.get('window', {}).get('min_width', 1000)
        min_height = self.settings.get('window', {}).get('min_height', 600)
        self.minsize(min_width, min_height)
        
        # ç»Ÿä¸€èƒŒæ™¯è‰²è®¾ç½®
        self._set_background_color()
    
    def _set_background_color(self):
        """è®¾ç½®èƒŒæ™¯è‰² - å…¼å®¹ä¸åŒçˆ¶ç±»"""
        try:
            if DRAG_DROP_AVAILABLE:
                self.configure(bg=MD.BG_MAIN)
            else:
                self.configure(fg_color=MD.BG_MAIN)
        except Exception as e:
            print(f"è®¾ç½®èƒŒæ™¯è‰²å¤±è´¥: {e}")
    
    def _setup_drag_drop(self):
        """è®¾ç½®æ‹–æ”¾åŠŸèƒ½ - å®‰å…¨é™çº§"""
        if not DRAG_DROP_AVAILABLE:
            print("æ‹–æ”¾åŠŸèƒ½ä¸å¯ç”¨ï¼Œå·²é™çº§ä¸ºæ–‡ä»¶é€‰æ‹©æ¨¡å¼")
            self._show_drag_drop_hint()
            return
        
        try:
            # ä¸ºä¸»çª—å£æ³¨å†Œæ‹–æ”¾
            self.drop_target_register(DND_FILES)
            self.dnd_bind('<<Drop>>', self._on_drop)
            
            # ä¸ºæ–‡ä»¶åˆ—è¡¨é¢æ¿æ³¨å†Œæ‹–æ”¾
            if hasattr(self, 'file_panel'):
                self.file_panel.drop_target_register(DND_FILES)
                self.file_panel.dnd_bind('<<Drop>>', self._on_drop)
            
            print("æ‹–æ”¾åŠŸèƒ½å·²å¯ç”¨")
        except Exception as e:
            print(f"è­¦å‘Š: æ‹–æ”¾åŠŸèƒ½åˆå§‹åŒ–å¤±è´¥: {e}")
    
    def _show_drag_drop_hint(self):
        """æ˜¾ç¤ºæ‹–æ”¾åŠŸèƒ½æç¤º"""
        hint = ctk.CTkLabel(
            self,
            text="ğŸ’¡ æç¤º: å®‰è£… tkinterdnd2 å¯ç”¨æ‹–æ”¾åŠŸèƒ½",
            font=MD.FONT_LABEL,
            text_color=MD.WARNING
        )
        hint.grid(row=0, column=0, columnspan=2, pady=MD.PAD_S, sticky='ew')
        self.after(5000, hint.destroy)
    
    def _on_drop(self, event):
        """å¤„ç†æ‹–æ”¾äº‹ä»¶"""
        files = self._parse_drop_files(event.data)
        
        if not files:
            return
        
        # å¼‚æ­¥å¤„ç†æ‹–æ”¾æ–‡ä»¶
        self._process_dropped_files_async(files)
    
    def _process_dropped_files_async(self, files):
        """å¼‚æ­¥å¤„ç†æ‹–æ”¾çš„æ–‡ä»¶"""
        import threading
        
        def process():
            added_files = 0
            added_folders = 0
            
            for path in files:
                if os.path.isfile(path):
                    if self.file_handler.add_file(path):
                        added_files += 1
                        if self.watch_enabled:
                            self.file_watcher.add_file(path)
                elif os.path.isdir(path):
                    count = self.file_handler.add_folder(path)
                    added_folders += count
                    if self.watch_enabled:
                        for file_info in self.file_handler.files[-count:]:
                            self.file_watcher.add_file(file_info.path)
            
            # UIæ›´æ–°å¿…é¡»åœ¨ä¸»çº¿ç¨‹
            self.after(0, lambda: self._on_drop_complete(added_files, added_folders))
        
        threading.Thread(target=process, daemon=True).start()
    
    def _on_drop_complete(self, added_files, added_folders):
        """æ‹–æ”¾å®Œæˆå›è°ƒ"""
        self.file_panel.refresh()
        self.control_panel.update_stats()
        
        messages = []
        if added_files > 0:
            messages.append(f"{added_files} ä¸ªæ–‡ä»¶")
        if added_folders > 0:
            messages.append(f"æ–‡ä»¶å¤¹ä¸­çš„ {added_folders} ä¸ªæ–‡ä»¶")
        
        if messages:
            msg = f"å·²æ·»åŠ : {', '.join(messages)}"
            self._show_toast(msg, 'success')
        else:
            self._show_toast("æ²¡æœ‰æ‰¾åˆ°æ”¯æŒçš„æ–‡ä»¶", 'warning')
    
    def _parse_drop_files(self, data):
        """è§£ææ‹–æ”¾çš„æ–‡ä»¶è·¯å¾„"""
        if data.startswith('{'):
            files = []
            current = ""
            in_braces = False
            
            for char in data:
                if char == '{':
                    in_braces = True
                elif char == '}':
                    in_braces = False
                    if current:
                        files.append(current)
                        current = ""
                elif in_braces:
                    current += char
            
            return files
        else:
            return data.split()
    
    def _on_file_changed(self, event_type: str, file_path: str):
        """æ–‡ä»¶å˜åŒ–å›è°ƒ"""
        if event_type == 'modified':
            self.modified_files.add(file_path)
            self._show_file_change_notification()
        elif event_type == 'deleted':
            self.deleted_files.add(file_path)
            self._show_file_change_notification()
    
    def _show_file_change_notification(self):
        """æ˜¾ç¤ºæ–‡ä»¶å˜åŒ–é€šçŸ¥"""
        modified_count = len(self.modified_files)
        deleted_count = len(self.deleted_files)
        
        messages = []
        if modified_count > 0:
            messages.append(f"{modified_count} ä¸ªæ–‡ä»¶å·²ä¿®æ”¹")
        if deleted_count > 0:
            messages.append(f"{deleted_count} ä¸ªæ–‡ä»¶å·²åˆ é™¤")
        
        if messages:
            msg = "æ£€æµ‹åˆ°æ–‡ä»¶å˜åŒ–: " + ", ".join(messages)
            
            if not hasattr(self, 'notification_bar') or not self.notification_bar.winfo_exists():
                self._create_notification_bar(msg)
            else:
                self.notification_label.configure(text=msg)
    
    def _create_notification_bar(self, message: str):
        """åˆ›å»ºé€šçŸ¥æ """
        self.notification_bar = ctk.CTkFrame(
            self,
            fg_color=MD.WARNING_CONTAINER,
            height=50
        )
        self.notification_bar.grid(row=0, column=0, columnspan=2, sticky='ew',
                                   padx=MD.PAD_M, pady=(MD.PAD_M, 0))

        content = ctk.CTkFrame(self.notification_bar, fg_color='transparent')
        content.grid(row=0, column=0, sticky='nsew', padx=MD.PAD_M, pady=MD.PAD_S)
        self.notification_bar.grid_columnconfigure(0, weight=1)
        self.notification_bar.grid_rowconfigure(0, weight=1)

        self.notification_label = ctk.CTkLabel(
            content,
            text=message,
            font=MD.FONT_BODY,
            text_color=MD.ON_SURFACE
        )
        self.notification_label.grid(row=0, column=0, sticky='w', padx=(0, MD.PAD_M))

        button_frame = ctk.CTkFrame(content, fg_color='transparent')
        button_frame.grid(row=0, column=1, sticky='e')

        ctk.CTkButton(
            button_frame,
            text="åˆ·æ–°",
            command=self._refresh_changed_files,
            fg_color=MD.PRIMARY,
            hover_color=MD.PRIMARY_CONTAINER,
            width=80,
            height=32
        ).grid(row=0, column=0, padx=(0, MD.PAD_S))

        ctk.CTkButton(
            button_frame,
            text="å…³é—­",
            command=self._close_notification,
            fg_color='transparent',
            hover_color=MD.BG_SURFACE,
            width=32,
            height=32
        ).grid(row=0, column=1)
    
    def _refresh_changed_files(self):
        """åˆ·æ–°å˜åŒ–çš„æ–‡ä»¶"""
        for file_path in self.deleted_files:
            self.file_handler.remove_file(file_path)
            self.file_watcher.remove_file(file_path)
        
        for file_path in self.modified_files:
            for file_info in self.file_handler.files:
                if file_info.path == file_path:
                    file_info.update_cache()
                    break
        
        self.file_panel.refresh()
        self.control_panel.update_stats()
        
        modified_count = len(self.modified_files)
        deleted_count = len(self.deleted_files)
        self.modified_files.clear()
        self.deleted_files.clear()
        
        self._close_notification()
        
        msg = f"å·²åˆ·æ–°: {modified_count} ä¸ªä¿®æ”¹, {deleted_count} ä¸ªåˆ é™¤"
        self._show_toast(msg, 'success')
    
    def _close_notification(self):
        """å…³é—­é€šçŸ¥æ """
        if hasattr(self, 'notification_bar') and self.notification_bar.winfo_exists():
            self.notification_bar.destroy()
        
        self.modified_files.clear()
        self.deleted_files.clear()
    
    def _build_ui(self):
        """æ„å»ºUI"""
        self.grid_columnconfigure(0, weight=3)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=0)  # ä¸ºtoasté€šçŸ¥é¢„ç•™ç©ºé—´
        
        self.file_panel = FileListPanel(self, self.file_handler)
        self.file_panel.grid(row=0, column=0, sticky='nsew', 
                           padx=(MD.PAD_M, MD.PAD_S), 
                           pady=MD.PAD_M)
        
        self.control_panel = ControlPanel(self, self.file_handler)
        self.control_panel.grid(row=0, column=1, sticky='nsew',
                              padx=(MD.PAD_S, MD.PAD_M),
                              pady=MD.PAD_M)
        
        self.file_panel.set_update_callback(self._on_file_update)
        self.file_panel.set_file_add_callback(self._on_files_added_to_list)
        self.control_panel.set_preview_callback(self._on_preview)
        self.control_panel.set_convert_callback(self._on_convert)
        
        # æ³¨å†Œæ‹–æ”¾ï¼ˆå»¶è¿Ÿåˆ°UIæ„å»ºå®Œæˆåï¼‰
        if DRAG_DROP_AVAILABLE:
            self.after(100, self._setup_drag_drop)
        
        self.toast_label = None
    
    def _on_files_added_to_list(self, file_paths: list):
        """æ–‡ä»¶æ·»åŠ åˆ°åˆ—è¡¨çš„å›è°ƒ"""
        if not self.watch_enabled:
            return
        
        for file_path in file_paths:
            self.file_watcher.add_file(file_path)
    
    def _on_window_configure(self, event):
        """çª—å£è°ƒæ•´äº‹ä»¶"""
        if event.widget != self:
            return
        
        if self._resize_after_id:
            self.after_cancel(self._resize_after_id)
        
        self._resize_after_id = self.after(100, self._handle_resize)
    
    def _handle_resize(self):
        """å¤„ç†çª—å£è°ƒæ•´"""
        self._resize_after_id = None
        self.update_idletasks()
    
    def _on_file_update(self, message: str, type: str = 'info'):
        """æ–‡ä»¶æ›´æ–°å›è°ƒ"""
        self.control_panel.update_stats()
        self._show_toast(message, type)
    
    def _on_preview(self, preview_type: str, data):
        """é¢„è§ˆå›è°ƒ"""
        if preview_type == 'template':
            TemplatePreviewDialog(self, data)
        
        elif preview_type == 'conversion':
            template = self.control_panel.get_template()
            max_files = self.settings.get('preview_max_files', 5)
            ConversionPreviewDialog(self, data, template, max_files)
        
        elif preview_type == 'warning':
            self._show_toast(f"è­¦å‘Š: {data}", 'warning')
    
    def _on_convert(self, action: str, data):
        """è½¬æ¢å›è°ƒ"""
        if action == 'warning':
            self._show_toast(f"è­¦å‘Š: {data}", 'warning')
            return
        
        if action == 'start':
            self._perform_conversion(data)
    
    def _perform_conversion(self, files):
        """æ‰§è¡Œè½¬æ¢ - å¼‚æ­¥ä¼˜åŒ–"""
        output_file = filedialog.asksaveasfilename(
            title="ä¿å­˜ Markdown æ–‡ä»¶",
            defaultextension=".md",
            filetypes=[("Markdown æ–‡ä»¶", "*.md"), ("æ‰€æœ‰æ–‡ä»¶", "*.*")]
        )
        
        if not output_file:
            return
        
        self.control_panel.show_progress()
        
        template = self.control_panel.get_template()
        self.converter.set_template(template)
        
        # å¼‚æ­¥è½¬æ¢
        import threading
        
        def convert_thread():
            def progress_callback(current, total, filename):
                self.after(0, lambda: self.control_panel.update_progress(current, total, filename))
            
            result = self.converter.convert_files(files, output_file, progress_callback)
            self.after(0, lambda: self._on_conversion_complete(result, output_file))
        
        threading.Thread(target=convert_thread, daemon=True).start()
    
    def _on_conversion_complete(self, result, output_file):
        """è½¬æ¢å®Œæˆå›è°ƒ"""
        self.after(1000, self.control_panel.hide_progress)
        
        if result['success']:
            self._show_toast(f"æˆåŠŸ: {result['message']}", 'success')
            messagebox.showinfo(
                "è½¬æ¢å®Œæˆ",
                f"{result['message']}\n\nä¿å­˜ä½ç½®: {output_file}"
            )
        else:
            self._show_toast(f"é”™è¯¯: {result['message']}", 'error')
            messagebox.showerror("è½¬æ¢å¤±è´¥", result['message'])
    
    def _show_toast(self, message: str, type: str = 'info'):
        """æ˜¾ç¤ºé€šçŸ¥æ¶ˆæ¯"""
        colors = {
            'success': MD.SUCCESS,
            'error': MD.ERROR,
            'warning': MD.WARNING,
            'info': MD.INFO
        }

        color = colors.get(type, MD.INFO)

        if self.toast_label:
            self.toast_label.destroy()

        self.toast_label = ctk.CTkLabel(
            self,
            text=message,
            font=MD.FONT_BODY,
            fg_color=color,
            text_color=MD.ON_PRIMARY,
            corner_radius=MD.RADIUS_MEDIUM,
            height=48
        )

        # ä½¿ç”¨gridå¸ƒå±€ï¼Œä½†éœ€è¦ç‰¹æ®Šå¤„ç†ï¼Œå› ä¸ºtoaståº”è¯¥æµ®åŠ¨åœ¨å…¶ä»–å†…å®¹ä¹‹ä¸Š
        self.toast_label.grid(row=1, column=0, columnspan=2, pady=(0, MD.PAD_M), sticky='ew')
        self.toast_label.lift()  # ç¡®ä¿æ˜¾ç¤ºåœ¨æœ€ä¸Šå±‚

        self.after(3000, lambda: self.toast_label.destroy() if self.toast_label else None)
    
    def _load_saved_state(self):
        """åŠ è½½ä¿å­˜çš„çŠ¶æ€"""
        recent_files = self.settings.get('recent_files', [])
        for file_path in recent_files:
            if os.path.exists(file_path):
                self.file_handler.add_file(file_path)
                if self.watch_enabled:
                    self.file_watcher.add_file(file_path)
        
        self.file_panel.refresh()
        self.control_panel.update_stats()
    
    def _save_state(self):
        """ä¿å­˜çŠ¶æ€"""
        geometry = self.geometry().split('+')[0]
        width, height = map(int, geometry.split('x'))
        
        self.settings.set('window', {
            'width': width,
            'height': height,
            'min_width': 1000,
            'min_height': 600
        })
        
        max_recent = self.settings.get('max_recent_files', 50)
        recent_files = [f.path for f in self.file_handler.files[:max_recent]]
        self.settings.set('recent_files', recent_files)
        
        self.settings.set('template', self.control_panel.get_template())
        
        self.settings.save()
    
    def _on_closing(self):
        """å…³é—­çª—å£"""
        if self.watch_enabled:
            self.file_watcher.stop()
        
        if self.settings.get('auto_save_config', True):
            self._save_state()
        
        self.destroy()
# ui\__init__.py

```python
# ç”¨æˆ·ç•Œé¢åŒ…

# ui\components\control_panel.py

```python
"""
æ§åˆ¶é¢æ¿ç»„ä»¶ - ä½¿ç”¨å¯æ»šåŠ¨å®¹å™¨é¿å…æŒ‰é’®æ¶ˆå¤±
"""

import customtkinter as ctk
import tkinter as tk
from config.theme import MD
from ui.widgets.material_card import Card, Btn
from core.converter import get_template_names, Converter
from core.file_handler import FileHandler, format_size

class ControlPanel(Card):
    """æ§åˆ¶é¢æ¿"""

    def __init__(self, master, file_handler: FileHandler, **kwargs):
        super().__init__(master, **kwargs)
        
        self.file_handler = file_handler
        self.converter = Converter()
        
        self.on_preview_callback = None
        self.on_convert_callback = None
        
        self._build_ui()
    
    def _build_ui(self):
        """æ„å»ºUI - ä½¿ç”¨å¯æ»šåŠ¨æ¡†æ¶"""
        # åˆ›å»ºå¯æ»šåŠ¨å®¹å™¨ä»¥é¿å…å†…å®¹è¢«é®æŒ¡
        scrollable_container = ctk.CTkScrollableFrame(
            self,
            fg_color='transparent'
        )
        scrollable_container.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_M)
        
        # æ ‡é¢˜
        self._build_header(scrollable_container)
        
        # æ¨¡æ¿é€‰æ‹©
        self._build_template_section(scrollable_container)
        
        # ç»Ÿè®¡å¡ç‰‡
        self._build_stats_section(scrollable_container)
        
        # æ“ä½œæŒ‰é’®ï¼ˆæ”¾åœ¨å¯æ»šåŠ¨åŒºåŸŸå†…ï¼Œç¡®ä¿å§‹ç»ˆå¯è®¿é—®ï¼‰
        self._build_actions(scrollable_container)
        
        # è¿›åº¦æ˜¾ç¤ºï¼ˆå›ºå®šåœ¨åº•éƒ¨ï¼‰
        self._build_progress()
    
    def _build_header(self, parent):
        """æ„å»ºæ ‡é¢˜"""
        header = ctk.CTkFrame(parent, fg_color='transparent')
        header.pack(fill='x', pady=(0, MD.PAD_M))
        
        title_container = ctk.CTkFrame(header, fg_color='transparent')
        title_container.pack(anchor='w')
        
        ctk.CTkLabel(
            title_container,
            text="è½¬æ¢è®¾ç½®",
            font=MD.FONT_HEADLINE,
            text_color=MD.ON_SURFACE
        ).pack(side='left')
        
        ctk.CTkLabel(
            title_container,
            text="âš™ï¸",
            font=("Segoe UI Emoji", 24)
        ).pack(side='left', padx=(MD.PAD_S, 0))
    
    def _build_template_section(self, parent):
        """æ„å»ºæ¨¡æ¿é€‰æ‹©åŒºåŸŸ"""
        section = Card(parent, fg_color=MD.BG_SURFACE)
        section.pack(fill='x', pady=(0, MD.PAD_M))
        
        section_container = ctk.CTkFrame(section, fg_color='transparent')
        section_container.pack(fill='both', padx=MD.PAD_M, pady=MD.PAD_M)
        
        # æ ‡é¢˜
        ctk.CTkLabel(
            section_container,
            text="Markdown æ¨¡æ¿",
            font=MD.FONT_TITLE,
            text_color=MD.TEXT_PRIMARY,
            anchor='w'
        ).pack(fill='x', pady=(0, MD.PAD_S))
        
        # æ¨¡æ¿é€‰æ‹©ä¸‹æ‹‰æ¡†
        self.template_var = tk.StringVar(value="é»˜è®¤")
        template_combo = ctk.CTkComboBox(
            section_container,
            values=get_template_names(),
            variable=self.template_var,
            state='readonly',
            fg_color=MD.BG_SURFACE,
            button_color=MD.ACCENT_BLUE,
            border_color=MD.BORDER,
            font=MD.FONT_UI,
            command=self._on_template_changed
        )
        template_combo.pack(fill='x', pady=(0, MD.PAD_S))
        
        # é¢„è§ˆæŒ‰é’®
        Btn(
            section_container,
            text="é¢„è§ˆæ¨¡æ¿",
            command=self._preview_template,
            kind='normal',
            width=200
        ).pack(fill='x')
    
    def _build_stats_section(self, parent):
        """æ„å»ºç»Ÿè®¡åŒºåŸŸ"""
        # åº•éƒ¨çŠ¶æ€æ ä¸€è¡Œæ˜¾ç¤ºæ‰€æœ‰ç»Ÿè®¡
        self.stats = ctk.CTkLabel(
            self,
            text="0/0 æ–‡ä»¶  â€¢  0 B  â€¢  0 è¯­è¨€",
            font=MD.FONT_UI,
            text_color=MD.TEXT_SECONDARY,
            anchor='w'
        )
        self.stats.pack(fill='x', padx=MD.PAD_M, pady=MD.PAD_S)
    
    def _build_actions(self, parent):
        """æ„å»ºæ“ä½œæŒ‰é’® - ç°åœ¨åœ¨æ»šåŠ¨åŒºåŸŸå†…"""
        actions = ctk.CTkFrame(parent, fg_color='transparent')
        actions.pack(fill='x', pady=(MD.PAD_M, MD.PAD_M))
        
        Btn(
            actions,
            text="é¢„è§ˆè½¬æ¢ç»“æœ",
            command=self._preview_conversion,
            kind='normal',
            height=48
        ).pack(fill='x', pady=(0, MD.PAD_M))

        Btn(
            actions,
            text="å¼€å§‹è½¬æ¢",
            command=self._start_conversion,
            kind='primary',
            height=56,
            font=MD.FONT_UI
        ).pack(fill='x')
        
        # æ·»åŠ ä¸€äº›åº•éƒ¨ç©ºé—´ï¼Œç¡®ä¿æŒ‰é’®ä¸ä¼šç´§è´´åº•éƒ¨
        ctk.CTkFrame(parent, fg_color='transparent', height=20).pack()
    
    def _build_progress(self):
        """æ„å»ºè¿›åº¦æ˜¾ç¤º - å›ºå®šåœ¨çª—å£åº•éƒ¨"""
        # åœ¨ä¸»å¡ç‰‡åº•éƒ¨åˆ›å»ºå›ºå®šçš„è¿›åº¦å®¹å™¨
        self.progress_container = ctk.CTkFrame(self, fg_color=MD.BG_SURFACE, height=60)
        
        progress_content = ctk.CTkFrame(self.progress_container, fg_color='transparent')
        progress_content.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_S)
        
        self.progress_bar = ctk.CTkProgressBar(
            progress_content,
            height=8,
            corner_radius=4,
            fg_color=MD.BG_SURFACE,
            progress_color=MD.ACCENT_BLUE
        )
        self.progress_bar.pack(fill='x', pady=(0, MD.PAD_S))
        
        self.progress_label = ctk.CTkLabel(
            progress_content,
            text="",
            font=MD.FONT_UI,
            text_color=MD.TEXT_SECONDARY
        )
        self.progress_label.pack()
        
        # åˆå§‹éšè—
        self.hide_progress()
    
    # äº‹ä»¶å¤„ç†
    def _on_template_changed(self, template_name):
        """æ¨¡æ¿æ”¹å˜äº‹ä»¶"""
        self.converter.set_template(template_name)
    
    def _preview_template(self):
        """é¢„è§ˆæ¨¡æ¿"""
        if self.on_preview_callback:
            self.on_preview_callback('template', self.template_var.get())
    
    def _preview_conversion(self):
        """é¢„è§ˆè½¬æ¢"""
        marked_files = self.file_handler.get_marked_files()
        
        if not marked_files:
            if self.on_preview_callback:
                self.on_preview_callback('warning', 'è¯·å…ˆé€‰æ‹©è¦é¢„è§ˆçš„æ–‡ä»¶')
            return
        
        if self.on_preview_callback:
            self.on_preview_callback('conversion', marked_files)
    
    def _start_conversion(self):
        """å¼€å§‹è½¬æ¢"""
        marked_files = self.file_handler.get_marked_files()
        
        if not marked_files:
            if self.on_convert_callback:
                self.on_convert_callback('warning', 'è¯·å…ˆé€‰æ‹©è¦è½¬æ¢çš„æ–‡ä»¶')
            return
        
        if self.on_convert_callback:
            self.on_convert_callback('start', marked_files)
    
    def update_stats(self):
        """æ›´æ–°ç»Ÿè®¡ä¿¡æ¯"""
        stats = self.file_handler.get_stats()
        self.stats.configure(
            text=f"{stats['marked']}/{stats['total']} æ–‡ä»¶  â€¢  "
                 f"{format_size(stats['size'])}  â€¢  "
                 f"{stats['languages']} è¯­è¨€"
        )
    
    def show_progress(self):
        """æ˜¾ç¤ºè¿›åº¦æ¡"""
        self.progress_container.pack(side='bottom', fill='x', padx=MD.PAD_M, pady=(0, MD.PAD_M))
        self.progress_bar.set(0)
    
    def hide_progress(self):
        """éšè—è¿›åº¦æ¡"""
        self.progress_container.pack_forget()
    
    def update_progress(self, current: int, total: int, filename: str = ""):
        """æ›´æ–°è¿›åº¦"""
        progress = current / total if total > 0 else 0
        self.progress_bar.set(progress)
        
        # æˆªæ–­è¿‡é•¿çš„æ–‡ä»¶å
        if len(filename) > 30:
            filename = "..." + filename[-27:]
        
        self.progress_label.configure(
            text=f"æ­£åœ¨å¤„ç†: {filename} ({current}/{total})"
        )
    
    def set_preview_callback(self, callback):
        """è®¾ç½®é¢„è§ˆå›è°ƒ"""
        self.on_preview_callback = callback
    
    def set_convert_callback(self, callback):
        """è®¾ç½®è½¬æ¢å›è°ƒ"""
        self.on_convert_callback = callback
    
    def get_template(self) -> str:
        """è·å–å½“å‰æ¨¡æ¿"""
        return self.template_var.get()
# ui\components\dialogs.py

```python
"""
å¯¹è¯æ¡†ç»„ä»¶
"""

import customtkinter as ctk
from config.theme import MD
from ui.widgets.material_card import Btn
from core.converter import preview_template, Converter
from core.file_handler import FileInfo

class PreviewDialog(ctk.CTkToplevel):
    """é¢„è§ˆå¯¹è¯æ¡†åŸºç±»"""
    
    def __init__(self, parent, title: str, width: int = 800, height: int = 600):
        super().__init__(parent)
        
        self.title(title)
        self.geometry(f"{width}x{height}")
        self.configure(fg_color=MD.BG_MAIN)
        
        # å±…ä¸­æ˜¾ç¤º
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")
        
        # æ¨¡æ€
        self.transient(parent)
        self.grab_set()
    
    def _build_header(self, title: str, subtitle: str = ""):
        """æ„å»ºå¤´éƒ¨"""
        header = ctk.CTkFrame(self, fg_color=MD.SURFACE_1, height=80)
        header.pack(fill='x', padx=MD.PAD_M, pady=MD.PAD_M)
        header.pack_propagate(False)
        
        header_content = ctk.CTkFrame(header, fg_color='transparent')
        header_content.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_M)
        
        ctk.CTkLabel(
            header_content,
            text=title,
            font=MD.FONT_HEADLINE,
            text_color=MD.ON_SURFACE
        ).pack(anchor='w')
        
        if subtitle:
            ctk.CTkLabel(
                header_content,
                text=subtitle,
                font=MD.FONT_BODY,
                text_color=MD.ON_SURFACE_VARIANT
            ).pack(anchor='w', pady=(MD.SPACING_XS, 0))
        
        return header
    
    def _build_content_area(self):
        """æ„å»ºå†…å®¹åŒºåŸŸ"""
        content = ctk.CTkFrame(self, fg_color=MD.SURFACE)
        content.pack(fill='both', expand=True, padx=MD.PAD_M, pady=(0, MD.PAD_M))
        
        textbox = ctk.CTkTextbox(
            content,
            font=MD.FONT_MONO,
            fg_color=MD.SURFACE,
            text_color=MD.ON_SURFACE,
            wrap='none'
        )
        textbox.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_M)
        
        return textbox
    
    def _build_footer(self):
        """æ„å»ºåº•éƒ¨æŒ‰é’®"""
        footer = ctk.CTkFrame(self, fg_color='transparent')
        footer.pack(fill='x', padx=MD.PAD_M, pady=(0, MD.PAD_M))
        
        Btn(
            footer,
            kind='normal',
            text="å…³é—­",
            command=self.destroy,
            width=120
        ).pack(side='right')
        
        return footer

class TemplatePreviewDialog(PreviewDialog):
    """æ¨¡æ¿é¢„è§ˆå¯¹è¯æ¡†"""
    
    def __init__(self, parent, template_name: str):
        super().__init__(parent, f"æ¨¡æ¿é¢„è§ˆ - {template_name}", 700, 500)
        
        self._build_header(
            f"{template_name} æ¨¡æ¿",
            "æŸ¥çœ‹æ¨¡æ¿çš„æ ¼å¼å’Œç»“æ„"
        )
        
        textbox = self._build_content_area()
        
        # æ˜¾ç¤ºæ¨¡æ¿å†…å®¹
        template_content = preview_template(template_name)
        textbox.insert('1.0', template_content)
        textbox.configure(state='disabled')
        
        self._build_footer()

class ConversionPreviewDialog(PreviewDialog):
    """è½¬æ¢é¢„è§ˆå¯¹è¯æ¡†"""
    
    def __init__(self, parent, files: list[FileInfo], template: str, max_files: int = 5):
        super().__init__(parent, "è½¬æ¢é¢„è§ˆ", 900, 700)
        
        self._build_header(
            f"ğŸ‘ï¸ è½¬æ¢é¢„è§ˆ",
            f"ä½¿ç”¨ {template} æ¨¡æ¿  â€¢  é¢„è§ˆå‰ {min(len(files), max_files)} ä¸ªæ–‡ä»¶"
        )
        
        textbox = self._build_content_area()
        
        # ç”Ÿæˆé¢„è§ˆå†…å®¹
        converter = Converter(template)
        preview_content = []
        
        for i, file_info in enumerate(files[:max_files]):
            preview_content.append(converter.convert_file(file_info))
        
        if len(files) > max_files:
            preview_content.append(
                f"\n{'='*80}\n"
                f"... è¿˜æœ‰ {len(files) - max_files} ä¸ªæ–‡ä»¶æœªåœ¨é¢„è§ˆä¸­æ˜¾ç¤º ...\n"
                f"{'='*80}\n"
            )
        
        textbox.insert('1.0', ''.join(preview_content))
        textbox.configure(state='disabled')
        
        self._build_footer()
# ui\components\file_list_panel.py

```python
"""
æ–‡ä»¶åˆ—è¡¨é¢æ¿ç»„ä»¶ - æ€§èƒ½ä¼˜åŒ–ç‰ˆæœ¬
"""

import customtkinter as ctk
import tkinter as tk
from tkinter import filedialog, ttk
from config.theme import MD
from ui.widgets.material_card import Card, Btn
from core.file_handler import FileHandler, get_all_languages, format_size
import os
from pathlib import Path
import threading

class FileListPanel(Card):
    """æ–‡ä»¶åˆ—è¡¨é¢æ¿"""
    
    def __init__(self, master, file_handler: FileHandler, **kwargs):
        super().__init__(master, **kwargs)
        
        self.file_handler = file_handler
        self.on_update_callback = None
        self.on_file_add_callback = None
        self._refresh_pending = False
        self._loading = False
        self._loading_animation_id = None
        self._update_lock = False  # æ·»åŠ æ›´æ–°é”

        self._build_ui()
    
    def _build_ui(self):
        """æ„å»ºUI"""
        # ä¸»å®¹å™¨
        container = ctk.CTkFrame(self, fg_color='transparent')
        container.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_M)
        
        # æ ‡é¢˜æ 
        self._build_header(container)
        
        # æœç´¢å’Œç­›é€‰æ 
        self._build_search_bar(container)
        
        # æ“ä½œæŒ‰é’®æ 
        self._build_action_bar(container)
        
        # æ–‡ä»¶åˆ—è¡¨ï¼ˆæ ‘çŠ¶è§†å›¾ï¼‰
        self._build_file_list(container)
        
        # åº•éƒ¨ç»Ÿè®¡
        self._build_footer(container)
    
    def _build_header(self, parent):
        """æ„å»ºæ ‡é¢˜æ """
        header = ctk.CTkFrame(parent, fg_color='transparent')
        header.pack(fill='x', pady=(0, MD.PAD_M))
        
        # æ ‡é¢˜
        title_container = ctk.CTkFrame(header, fg_color='transparent')
        title_container.pack(side='left')
        
        ctk.CTkLabel(
            title_container,
            text="æ–‡ä»¶ç®¡ç†",
            font=MD.FONT_HEADLINE,
            text_color=MD.ON_SURFACE
        ).pack(side='left')
        
        ctk.CTkLabel(
            title_container,
            text="ğŸ“‚",
            font=("Segoe UI Emoji", 16)
        ).pack(side='left', padx=(MD.PAD_S, 0))
        
        # åŠ è½½æŒ‡ç¤ºå™¨å®¹å™¨
        self.loading_container = ctk.CTkFrame(header, fg_color=MD.BG_SURFACE, corner_radius=MD.RADIUS)
        
        # åŠ è½½è¿›åº¦æ¡ï¼ˆä¸ç¡®å®šæ¨¡å¼ï¼‰
        self.loading_progress = ctk.CTkProgressBar(
            self.loading_container,
            height=6,
            corner_radius=3,
            fg_color=MD.SURFACE,
            progress_color=MD.PRIMARY,
            mode='indeterminate'
        )
        self.loading_progress.pack(padx=MD.PAD_M, pady=(MD.PAD_S, MD.PAD_S))
        
        # åŠ è½½æ–‡æœ¬
        self.loading_label = ctk.CTkLabel(
            self.loading_container,
            text="åŠ è½½ä¸­...",
            font=MD.FONT_BODY,
            text_color=MD.PRIMARY
        )
        self.loading_label.pack(padx=MD.PAD_M, pady=(0, MD.PAD_S))
    
    def _build_search_bar(self, parent):
        """æ„å»ºæœç´¢æ """
        search_bar = ctk.CTkFrame(parent, fg_color='transparent')
        search_bar.pack(fill='x', pady=(0, MD.PAD_M))
        
        # æœç´¢æ¡†
        self.search_var = tk.StringVar()
        self.search_var.trace('w', lambda *args: self._schedule_refresh())
        
        search_entry = ctk.CTkEntry(
            search_bar,
            textvariable=self.search_var,
            placeholder_text="ğŸ” æœç´¢æ–‡ä»¶å...",
            width=300,
            fg_color=MD.BG_SURFACE,
            border_color=MD.BORDER,
            corner_radius=MD.RADIUS
        )
        search_entry.pack(side='left', fill='x', expand=True, padx=(0, MD.PAD_S))
        
        # è¯­è¨€ç­›é€‰
        self.language_var = tk.StringVar(value="å…¨éƒ¨è¯­è¨€")
        self.language_var.trace('w', lambda *args: self._schedule_refresh())
        
        languages = ["å…¨éƒ¨è¯­è¨€"] + get_all_languages()
        language_combo = ctk.CTkComboBox(
            search_bar,
            values=languages,
            variable=self.language_var,
            state='readonly',
            width=150,
            fg_color=MD.BG_SURFACE,
            button_color=MD.PRIMARY,
            border_color=MD.OUTLINE,
            font=MD.FONT_BODY
        )
        language_combo.pack(side='left')
    
    def _build_action_bar(self, parent):
        """æ„å»ºæ“ä½œæŒ‰é’®æ """
        action_bar = ctk.CTkFrame(parent, fg_color='transparent')
        action_bar.pack(fill='x', pady=(0, MD.PAD_M))
        
        action_bar.grid_columnconfigure(0, weight=1)
        action_bar.grid_columnconfigure(1, weight=0)
        
        # å·¦ä¾§æŒ‰é’®å®¹å™¨
        left_buttons = ctk.CTkFrame(action_bar, fg_color='transparent')
        left_buttons.grid(row=0, column=0, sticky='w', padx=(0, MD.PAD_S))
        
        Btn(
            left_buttons,
            kind='primary',
            text="â• æ–‡ä»¶",
            command=self._add_files,
            width=100
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            left_buttons,
            kind='primary',
            text="æ–‡ä»¶å¤¹",
            command=self._add_folder,
            width=100
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            left_buttons,
            kind='normal',
            text="åˆ·æ–°",
            command=self._refresh_files,
            width=50
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            left_buttons,
            kind='danger',
            text="æ¸…é™¤æ‰€æœ‰",
            command=self._clear_files,
            width=50
        ).pack(side='left')
        
        # å³ä¾§æŒ‰é’®å®¹å™¨
        right_buttons = ctk.CTkFrame(action_bar, fg_color='transparent')
        right_buttons.grid(row=0, column=1, sticky='e')
        
        Btn(
            right_buttons,
            kind='normal',
            text="å…¨é€‰",
            command=lambda: self._mark_all(True),
            width=60
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            right_buttons,
            kind='normal',
            text="å…¨ä¸é€‰",
            command=lambda: self._mark_all(False),
            width=70
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            right_buttons,
            kind='normal',
            text="å±•å¼€",
            command=self._expand_all,
            width=60
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            right_buttons,
            kind='normal',
            text="æŠ˜å ",
            command=self._collapse_all,
            width=60
        ).pack(side='left')
    
    def _build_file_list(self, parent):
        """æ„å»ºæ–‡ä»¶åˆ—è¡¨ï¼ˆæ ‘çŠ¶è§†å›¾ï¼‰- æ€§èƒ½ä¼˜åŒ–ç‰ˆ"""
        # åˆ—è¡¨å®¹å™¨
        list_container = ctk.CTkFrame(parent, fg_color=MD.SURFACE)
        list_container.pack(fill='both', expand=True, pady=(0, MD.PAD_M))
        
        # åˆ›å»ºæ ·å¼
        style = ttk.Style()
        style.theme_use('clam')
        
        # é…ç½® Treeview æ ·å¼
        style.configure(
            "Compact.Treeview",
            background=MD.BG_SURFACE,
            foreground=MD.TEXT_PRIMARY,
            fieldbackground=MD.BG_SURFACE,
            borderwidth=0,
            font=MD.FONT_UI,
            rowheight=18
        )
        
        style.configure(
            "Compact.Treeview.Heading",
            background=MD.BG_ELEVATED,
            foreground=MD.TEXT_PRIMARY,
            borderwidth=1,
            relief="flat",
            font=MD.FONT_TITLE
        )

        style.map(
            "Compact.Treeview",
            background=[('selected', MD.BG_ELEVATED)],
            foreground=[('selected', MD.TEXT_PRIMARY)]
        )

        # åˆ›å»º Treeview
        columns = ('status', 'language', 'size')
        self.file_tree = ttk.Treeview(
            list_container,
            columns=columns,
            show='tree headings',
            style="Compact.Treeview",
            selectmode='browse'
        )
        
        # é…ç½®åˆ—
        self.file_tree.column('#0', width=400, minwidth=180, stretch=True)
        self.file_tree.column('status', width=50, minwidth=50, anchor='center', stretch=False)
        self.file_tree.column('language', width=80, minwidth=70, anchor='center', stretch=False)
        self.file_tree.column('size', width=70, minwidth=70, anchor='e', stretch=False)

        # è®¾ç½®åˆ—æ ‡é¢˜
        self.file_tree.heading('#0', text='[+] æ–‡ä»¶è·¯å¾„', anchor='w')
        self.file_tree.heading('status', text='çŠ¶æ€', anchor='center')
        self.file_tree.heading('language', text='è¯­è¨€', anchor='center')
        self.file_tree.heading('size', text='å¤§å°', anchor='e')
        
        # æ»šåŠ¨æ¡
        vsb = ttk.Scrollbar(list_container, orient="vertical", command=self.file_tree.yview)
        self.file_tree.configure(yscrollcommand=vsb.set)
        
        # å¸ƒå±€
        self.file_tree.grid(row=0, column=0, sticky='nsew')
        vsb.grid(row=0, column=1, sticky='ns')
        
        list_container.grid_rowconfigure(0, weight=1)
        list_container.grid_columnconfigure(0, weight=1)
        
        # ç»‘å®šäº‹ä»¶
        self.file_tree.bind('<Double-Button-1>', self._on_item_double_click)
        self.file_tree.bind('<space>', self._on_space_press)
        self.file_tree.bind('<Button-1>', self._on_item_click)
        
        # å­˜å‚¨èŠ‚ç‚¹æ˜ å°„
        self.item_to_path = {}
        self.path_to_item = {}
    
    def _build_footer(self, parent):
        """æ„å»ºåº•éƒ¨ç»Ÿè®¡"""
        footer = ctk.CTkFrame(parent, fg_color='transparent')
        footer.pack(fill='x')
        
        self.stats_label = ctk.CTkLabel(
            footer,
            text="0 ä¸ªæ–‡ä»¶",
            font=MD.FONT_BODY,
            text_color=MD.ON_SURFACE_VARIANT
        )
        self.stats_label.pack(side='left')
    
    # äº‹ä»¶å¤„ç†
    def _add_files(self):
        """æ·»åŠ æ–‡ä»¶"""
        filetypes = [
            ("æ‰€æœ‰æ”¯æŒçš„æ–‡ä»¶", "*.py *.js *.java *.cpp *.html *.css"),
            ("æ‰€æœ‰æ–‡ä»¶", "*.*")
        ]
        
        files = filedialog.askopenfilenames(title="é€‰æ‹©ä»£ç æ–‡ä»¶", filetypes=filetypes)
        
        if files:
            self._show_loading(True)
            def add_files_thread():
                count = self.file_handler.add_files(list(files))
                self.after(0, lambda: self._on_files_added(count))
            
            thread = threading.Thread(target=add_files_thread, daemon=True)
            thread.start()
    
    def _on_files_added(self, count):
        """æ–‡ä»¶æ·»åŠ å®Œæˆå›è°ƒ"""
        self._show_loading(False)
        self.refresh()

        # è°ƒç”¨æ–‡ä»¶æ·»åŠ å›è°ƒï¼Œä¼ é€’æ–°æ·»åŠ çš„æ–‡ä»¶è·¯å¾„
        if self.on_file_add_callback and count > 0:
            added_files = [f.path for f in self.file_handler.files[-count:]]
            self.on_file_add_callback(added_files)

        if self.on_update_callback:
            self.on_update_callback(f"âœ… æˆåŠŸæ·»åŠ äº† {count} ä¸ªæ–‡ä»¶", 'success')
    
    def _add_folder(self):
        """æ·»åŠ æ–‡ä»¶å¤¹"""
        folder = filedialog.askdirectory(title="é€‰æ‹©æ–‡ä»¶å¤¹")
        
        if folder:
            self._show_loading(True)
            def add_folder_thread():
                count = self.file_handler.add_folder(folder)
                self.after(0, lambda: self._on_folder_added(count))
            
            thread = threading.Thread(target=add_folder_thread, daemon=True)
            thread.start()
    
    def _on_folder_added(self, count):
        """æ–‡ä»¶å¤¹æ·»åŠ å®Œæˆå›è°ƒ"""
        self._show_loading(False)
        self.refresh()

        # è°ƒç”¨æ–‡ä»¶æ·»åŠ å›è°ƒï¼Œä¼ é€’æ–°æ·»åŠ çš„æ–‡ä»¶è·¯å¾„
        if self.on_file_add_callback and count > 0:
            added_files = [f.path for f in self.file_handler.files[-count:]]
            self.on_file_add_callback(added_files)

        if self.on_update_callback:
            self.on_update_callback(f"âœ… æˆåŠŸä»æ–‡ä»¶å¤¹æ·»åŠ äº† {count} ä¸ªæ–‡ä»¶", 'success')
    
    def _refresh_files(self):
        """åˆ·æ–°æ–‡ä»¶åˆ—è¡¨"""
        if self._loading:
            return
        
        self._show_loading(True)
        
        def refresh_thread():
            result = self.file_handler.refresh_files()
            self.after(0, lambda: self._on_files_refreshed(result))
        
        thread = threading.Thread(target=refresh_thread, daemon=True)
        thread.start()
    
    def _on_files_refreshed(self, result):
        """æ–‡ä»¶åˆ·æ–°å®Œæˆå›è°ƒ"""
        self._show_loading(False)
        self.refresh()
        
        removed_count = result['removed_count']
        modified_count = result['modified_count']
        
        messages = []
        if removed_count > 0:
            messages.append(f"ç§»é™¤äº† {removed_count} ä¸ªä¸å­˜åœ¨çš„æ–‡ä»¶")
        if modified_count > 0:
            messages.append(f"æ£€æµ‹åˆ° {modified_count} ä¸ªæ–‡ä»¶å·²ä¿®æ”¹")
        
        if messages:
            message = "ğŸ”„ åˆ·æ–°å®Œæˆ: " + ", ".join(messages)
        else:
            message = "ğŸ”„ åˆ·æ–°å®Œæˆï¼Œæ‰€æœ‰æ–‡ä»¶éƒ½æ˜¯æœ€æ–°çš„"
        
        if self.on_update_callback:
            self.on_update_callback(message, 'success')
    
    def _clear_files(self):
        """æ¸…ç©ºæ–‡ä»¶"""
        if not self.file_handler.files:
            return
        
        from tkinter import messagebox
        if messagebox.askyesno("ç¡®è®¤æ¸…ç©º", "ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ–‡ä»¶å—ï¼Ÿ"):
            self.file_handler.clear()
            self.refresh()
            
            if self.on_update_callback:
                self.on_update_callback("ğŸ—‘ï¸ å·²æ¸…ç©ºæ–‡ä»¶åˆ—è¡¨", 'info')
    
    def _mark_all(self, marked: bool):
        """å…¨é€‰/å…¨ä¸é€‰"""
        self.file_handler.mark_all(marked)
        self.refresh()
        
        if self.on_update_callback:
            msg = "âœ… å·²å…¨é€‰" if marked else "â¬œ å·²å–æ¶ˆå…¨é€‰"
            self.on_update_callback(msg, 'info')
    
    def _expand_all(self):
        """å±•å¼€æ‰€æœ‰èŠ‚ç‚¹"""
        def expand_recursive(item):
            self.file_tree.item(item, open=True)
            for child in self.file_tree.get_children(item):
                expand_recursive(child)
        
        for item in self.file_tree.get_children():
            expand_recursive(item)
    
    def _collapse_all(self):
        """æŠ˜å æ‰€æœ‰èŠ‚ç‚¹"""
        def collapse_recursive(item):
            self.file_tree.item(item, open=False)
            for child in self.file_tree.get_children(item):
                collapse_recursive(child)
        
        for item in self.file_tree.get_children():
            collapse_recursive(item)
    
    def _schedule_refresh(self):
        """å»¶è¿Ÿåˆ·æ–°ï¼ˆé˜²æŠ–ï¼‰- ä¼˜åŒ–ç‰ˆ"""
        if self._refresh_pending:
            return
        
        self._refresh_pending = True
        # å¢åŠ å»¶è¿Ÿæ—¶é—´ï¼Œå‡å°‘åˆ·æ–°é¢‘ç‡
        self.after(500, self._execute_refresh)  # ä»300msæ”¹ä¸º500ms
    
    def _execute_refresh(self):
        """æ‰§è¡Œåˆ·æ–°"""
        self._refresh_pending = False
        self._filter_files()
    
    def _filter_files(self):
        """ç­›é€‰æ–‡ä»¶"""
        search = self.search_var.get()
        language = self.language_var.get()
        
        filtered = self.file_handler.filter_files(
            search=search if search else None,
            language=language if language != "å…¨éƒ¨è¯­è¨€" else None
        )
        
        self._display_files(filtered)
    
    def _on_item_click(self, event):
        """å•å‡»é¡¹ç›®"""
        item = self.file_tree.identify('item', event.x, event.y)
        if item and item in self.item_to_path:
            file_path = self.item_to_path[item]
            self._toggle_mark(file_path)
    
    def _on_item_double_click(self, event):
        """åŒå‡»é¡¹ç›®"""
        item = self.file_tree.selection()
        if item:
            if self.file_tree.get_children(item[0]):
                current_state = self.file_tree.item(item[0], 'open')
                self.file_tree.item(item[0], open=not current_state)
    
    def _on_space_press(self, event):
        """ç©ºæ ¼é”®åˆ‡æ¢æ ‡è®°"""
        item = self.file_tree.selection()
        if item and item[0] in self.item_to_path:
            file_path = self.item_to_path[item[0]]
            self._toggle_mark(file_path)
    
    def _toggle_mark(self, file_path: str):
        """åˆ‡æ¢æ–‡ä»¶æ ‡è®°çŠ¶æ€"""
        self.file_handler.toggle_mark(file_path)
        self.refresh()
    
    def _build_tree_structure(self, files):
        """æ„å»ºæ ‘çŠ¶ç»“æ„"""
        tree_dict = {}
        
        for file_info in files:
            path = Path(file_info.path)
            parts = path.parts
            
            current = tree_dict
            for i, part in enumerate(parts[:-1]):
                if part not in current:
                    current[part] = {}
                current = current[part]
            
            filename = parts[-1]
            current[filename] = file_info
        
        return tree_dict
    
    def _insert_tree_recursive(self, parent_item, tree_dict, prefix=""):
        """é€’å½’æ’å…¥æ ‘èŠ‚ç‚¹"""
        for name, value in sorted(tree_dict.items()):
            if isinstance(value, dict):
                folder_item = self.file_tree.insert(
                    parent_item,
                    'end',
                    text=f"[+] {name}",
                    values=('', '', ''),
                    open=True
                )
                self._insert_tree_recursive(folder_item, value, prefix + name + os.sep)
            else:
                file_info = value
                icon = "[x]" if file_info.marked else "[ ]"

                file_item = self.file_tree.insert(
                    parent_item,
                    'end',
                    text=f" {name}",
                    values=(icon, file_info.language, format_size(file_info.size)),
                    tags=('file',)
                )
                
                self.item_to_path[file_item] = file_info.path
                self.path_to_item[file_info.path] = file_item
    
    def _display_files(self, files):
        """æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨ - æ€§èƒ½ä¼˜åŒ–ç‰ˆï¼ˆæ¶ˆé™¤æ’•è£‚ï¼‰"""
        # é˜²æ­¢é‡å¤æ›´æ–°
        if self._update_lock:
            return
        
        self._update_lock = True
        
        try:
            # 1. æš‚åœUIæ›´æ–°
            self.file_tree.configure(selectmode='none')
            
            # 2. æ‰¹é‡åˆ é™¤ï¼ˆä½¿ç”¨detachè€Œédeleteå¯ä»¥æ›´å¿«ï¼‰
            children = self.file_tree.get_children()
            if children:
                self.file_tree.delete(*children)  # æ‰¹é‡åˆ é™¤
            
            self.item_to_path.clear()
            self.path_to_item.clear()
            
            if not files:
                # ç©ºçŠ¶æ€
                self.file_tree.insert(
                    '',
                    'end',
                    text='  æš‚æ— æ–‡ä»¶ - ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®æ·»åŠ æ–‡ä»¶æˆ–æ–‡ä»¶å¤¹',
                    values=('', '', '')
                )
            else:
                # 3. æ„å»ºå¹¶æ‰¹é‡æ’å…¥
                tree_structure = self._build_tree_structure(files)
                self._insert_tree_recursive('', tree_structure)
            
            # 4. å¼ºåˆ¶æ›´æ–°ä¸€æ¬¡UI
            self.file_tree.update_idletasks()
            
        finally:
            # 5. å»¶è¿Ÿæ¢å¤é€‰æ‹©æ¨¡å¼ï¼Œç¡®ä¿UIå®Œå…¨æ›´æ–°
            self.after(10, self._restore_tree_state)
    
    def _restore_tree_state(self):
        """æ¢å¤æ ‘çŠ¶æ€"""
        self.file_tree.configure(selectmode='browse')
        self._update_lock = False
    
    def _animate_loading(self):
        """åŠ è½½åŠ¨ç”»"""
        if self._loading:
            current = self.loading_progress.get()
            if current >= 1.0:
                self.loading_progress.set(0)
            else:
                self.loading_progress.set(current + 0.05)
            
            self._loading_animation_id = self.after(50, self._animate_loading)
    
    def _show_loading(self, show: bool):
        """æ˜¾ç¤º/éšè—åŠ è½½æŒ‡ç¤ºå™¨"""
        self._loading = show
        
        if show:
            self.loading_container.pack(side='right', padx=MD.PAD_M)
            self.loading_progress.set(0)
            self._animate_loading()
        else:
            if self._loading_animation_id:
                self.after_cancel(self._loading_animation_id)
                self._loading_animation_id = None
            self.loading_container.pack_forget()
    
    def refresh(self):
        """åˆ·æ–°æ˜¾ç¤º"""
        self._filter_files()
        
        # æ›´æ–°ç»Ÿè®¡
        stats = self.file_handler.get_stats()
        self.stats_label.configure(
            text=f"ğŸ“Š {stats['marked']}/{stats['total']} ä¸ªæ–‡ä»¶å·²é€‰ä¸­  â€¢  "
                 f"ğŸ’¾ å…± {format_size(stats['size'])}  â€¢  "
                 f"ğŸ”¤ {stats['languages']} ç§è¯­è¨€"
        )
    
    def set_update_callback(self, callback):
        """è®¾ç½®æ›´æ–°å›è°ƒ"""
        self.on_update_callback = callback

    def set_file_add_callback(self, callback):
        """è®¾ç½®æ–‡ä»¶æ·»åŠ å›è°ƒ"""
        self.on_file_add_callback = callback
# ui\components\__init__.py

```python
# UIç»„ä»¶åŒ…

# ui\widgets\material_card.py

```python
"""
ç®€åŒ–å¡ç‰‡ç»„ä»¶
"""

import customtkinter as ctk
from config.theme import MD

class Card(ctk.CTkFrame):
    """ç®€åŒ–å¡ç‰‡"""

    def __init__(self, master, **kwargs):
        kwargs.setdefault('fg_color', MD.BG_SURFACE)
        kwargs.setdefault('corner_radius', MD.RADIUS)
        super().__init__(master, **kwargs)

class Btn(ctk.CTkButton):
    """ç®€åŒ–æŒ‰é’® - 3ç§å˜ä½“"""

    def __init__(self, master, kind='normal', **kwargs):
        # kind: 'primary', 'danger', 'normal'
        if kind == 'primary':
            kwargs.update({
                'fg_color': MD.ACCENT_BLUE,
                'hover_color': MD.BG_ELEVATED,
                'text_color': '#FFFFFF'
            })
        elif kind == 'danger':
            kwargs.update({
                'fg_color': MD.ACCENT_RED,
                'hover_color': MD.BG_ELEVATED,
                'text_color': '#FFFFFF'
            })
        else:  # normal
            kwargs.update({
                'fg_color': 'transparent',
                'border_width': 1,
                'border_color': MD.BORDER,
                'hover_color': MD.BG_ELEVATED,
                'text_color': MD.TEXT_PRIMARY
            })

        kwargs.setdefault('corner_radius', MD.RADIUS)
        kwargs.setdefault('font', MD.FONT_UI)
        kwargs.setdefault('height', 28)

        super().__init__(master, **kwargs)
# ui\widgets\__init__.py

```python
# UIå°éƒ¨ä»¶åŒ…

# utils\helpers.py

```python
"""
è¾…åŠ©å·¥å…·å‡½æ•°
"""

import os
from typing import Optional

def get_relative_path(file_path: str, base_path: Optional[str] = None) -> str:
    """è·å–ç›¸å¯¹è·¯å¾„"""
    if base_path is None:
        base_path = os.getcwd()
    
    try:
        return os.path.relpath(file_path, base_path)
    except ValueError:
        return file_path

def truncate_string(s: str, max_length: int, suffix: str = '...') -> str:
    """æˆªæ–­å­—ç¬¦ä¸²"""
    if len(s) <= max_length:
        return s
    return s[:max_length - len(suffix)] + suffix

def validate_file_path(path: str) -> bool:
    """éªŒè¯æ–‡ä»¶è·¯å¾„"""
    return os.path.isfile(path) and os.path.exists(path)

# utils\__init__.py

```python
# å·¥å…·å‡½æ•°åŒ…



---

## è½¬æ¢ç»Ÿè®¡

- æˆåŠŸè½¬æ¢: **19** ä¸ªæ–‡ä»¶
- æ€»è®¡å¤„ç†: **19** ä¸ªæ–‡ä»¶
- å®Œæˆæ—¶é—´: 2025-10-14 19:07:50

---

æ–‡æ¡£ç”Ÿæˆå®Œæˆ
