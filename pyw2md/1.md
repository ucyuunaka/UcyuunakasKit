# 代码转Markdown文档

**生成时间:** 2025-10-14 19:07:50
**文件数量:** 19
**总大小:** 79.2 KB
**编程语言:** JSON, Python
**使用模板:** 默认

---

# config.json

```json
{
  "window": {
    "width": 1280,
    "height": 800,
    "min_width": 1000,
    "min_height": 600
  },
  "template": "默认",
  "recent_files": [],
  "max_recent_files": 50,
  "auto_save_config": true,
  "preview_max_files": 5,
  "auto_watch_files": true,
  "watch_debounce_time": 1.0
}
# main.py

```python
"""
代码转Markdown工具
"""

import customtkinter as ctk
from ui.app import MaterialApp

def main():
    """应用入口"""
    ctk.set_appearance_mode("dark")
    ctk.set_default_color_theme("blue")

    app = MaterialApp()
    app.mainloop()

if __name__ == "__main__":
    main()

# config\settings.py

```python
"""
应用配置管理
"""

import json
import os
from typing import Dict, Any

class Settings:
    """配置管理器"""

    def __init__(self, config_file: str = "config.json"):
        self.config_file = config_file
        self.config: Dict[str, Any] = {}
        self.load()

    def load(self):
        """加载配置"""
        if not os.path.exists(self.config_file):
            self.config = self._default_config()
            self.save()
            return

        try:
            with open(self.config_file, 'r', encoding='utf-8') as f:
                self.config = json.load(f)
        except Exception as e:
            print(f"加载配置失败: {e}")
            self.config = self._default_config()

    def save(self):
        """保存配置"""
        try:
            with open(self.config_file, 'w', encoding='utf-8') as f:
                json.dump(self.config, f, indent=2, ensure_ascii=False)
        except Exception as e:
            print(f"保存配置失败: {e}")

    def get(self, key: str, default=None):
        """获取配置项"""
        return self.config.get(key, default)

    def set(self, key: str, value: Any):
        """设置配置项"""
        self.config[key] = value

    def _default_config(self) -> Dict[str, Any]:
        """默认配置"""
        return {
            "window": {
                "width": 1280,
                "height": 800,
                "min_width": 1000,
                "min_height": 600
            },
            "template": "默认",
            "recent_files": [],
            "max_recent_files": 50,
            "auto_save_config": True,
            "preview_max_files": 5,
            "auto_watch_files": True,  # 新增：自动监控文件变化
            "watch_debounce_time": 1.0  # 新增：监控防抖时间（秒）
        }

# config\theme.py

```python
"""
简化主题 - Catppuccin Mocha启发
实用主题 - 高对比度深色
"""

class MD:
    # 背景（3级足够）- 添加向后兼容别名
    BG_MAIN = "#1E1E2E"      # 主背景
    BG_SURFACE = "#2A2A3A"   # 卡片
    BG_ELEVATED = "#363650"  # 高亮/悬停
    BACKGROUND = "#1E1E2E"   # 向后兼容

    # 文字（2级足够）
    TEXT_PRIMARY = "#CDD6F4"   # 主文字
    TEXT_SECONDARY = "#BAC2DE" # 次要文字

    # 强调色（3个足够）
    ACCENT_BLUE = "#89B4FA"    # 主操作
    ACCENT_GREEN = "#A6E3A1"   # 成功
    ACCENT_RED = "#F38BA8"     # 错误/危险
    ACCENT_YELLOW = "#F9E2AF"  # 警告

    # 别名（向后兼容）
    PRIMARY = "#89B4FA"        # 主色
    SUCCESS = "#A6E3A1"        # 成功色
    ERROR = "#F38BA8"          # 错误色

    # 边框
    BORDER = "#45475A"

    # 间距（2个足够）
    PAD_S = 8
    PAD_M = 12

    # 圆角（1个足够）
    RADIUS = 4

    # 字体
    FONT_MONO = ("Cascadia Code", 9)  # 更现代的等宽字体
    FONT_UI = ("Segoe UI", 9)
    FONT_TITLE = ("Segoe UI Semibold", 10)

    # Material Design 向后兼容性 - 添加缺失的颜色常量
    ON_SURFACE = "#CDD6F4"      # 表面文字色
    ON_SURFACE_VARIANT = "#BAC2DE"  # 表面变体文字色
    ON_PRIMARY = "#FFFFFF"      # 主色文字
    SURFACE = "#2A2A3A"         # 表面（通用）
    SURFACE_1 = "#2A2A3A"       # 表面1
    SURFACE_2 = "#363650"       # 表面2
    FONT_HEADLINE = ("Segoe UI Semibold", 12)  # 标题字体
    FONT_BODY = ("Segoe UI", 10)    # 正文字体
    FONT_LABEL = ("Segoe UI", 9)    # 标签字体
    FONT_MONO = ("Cascadia Code", 9)  # 等宽字体

    # 警告颜色
    WARNING = "#FAB387"         # 警告色
    WARNING_CONTAINER = "#7C2D12"  # 警告容器

    # 主色容器
    PRIMARY_CONTAINER = "#1E40AF"   # 主色容器

    # 轮廓色
    OUTLINE = "#797979"         # 轮廓色

    # 信息色
    INFO = "#74C7EC"            # 信息色

    # 圆角大小
    RADIUS_MEDIUM = 8           # 中等圆角

    # 间距常量（向后兼容）
    SPACING_XS = 4              # 极小间距

# 快捷访问保持不变
MD = MD

# config\__init__.py

```python

# core\converter.py

```python
"""
Markdown 转换核心模块 - 性能优化版
"""

import os
import time
from typing import Callable, Optional
from io import StringIO
from concurrent.futures import ThreadPoolExecutor, as_completed
from core.file_handler import FileInfo

# Markdown 模板（保持不变）
TEMPLATES = {
    "默认": """# {relative_path}

```{language}
{content}
""",

"详细信息": """## {basename}
路径: {relative_path}
语言: {language}
大小: {size}
修改时间: {mtime}

{content}
""",

"GitHub 风格": """## {basename}

{content}
<details> <summary>文件信息</summary>
完整路径: {relative_path}
编程语言: {language}
文件大小: {size}
最后修改: {mtime}
</details>
""",

"简洁模式": """```{language}
// {relative_path}
{content}


""",
    
    "带目录": """### {relative_path}

<details open>
<summary>点击展开/折叠</summary>

```{language}
{content}
</details>
""",

"专业文档": """## {basename}
路径: {relative_path}
语言: {language}
大小: {size}

{content}
最后修改: {mtime}

"""
}

class Converter:
    """Markdown 转换器 - 性能优化版"""

    def __init__(self, template: str = "默认", max_workers: int = 4):
        self.template = template
        self.base_path = os.getcwd()
        self.max_workers = max_workers  # 线程池大小
        self.chunk_size = 50  # 批量写入文件数

    def set_template(self, template: str):
        """设置模板"""
        if template in TEMPLATES:
            self.template = template

    def set_base_path(self, path: str):
        """设置基准路径"""
        self.base_path = path

    def convert_file(self, file_info: FileInfo) -> str:
            """转换单个文件 - 优化字符串拼接"""
            try:
                # 读取文件内容（使用 with 自动关闭）
                with open(file_info.path, 'r', encoding='utf-8') as f:
                    content = f.read()

                # 准备模板变量
                basename = os.path.basename(file_info.path)

                try:
                    relative_path = os.path.relpath(file_info.path, self.base_path)
                except ValueError:
                    relative_path = file_info.path

                mtime = time.strftime(
                    "%Y-%m-%d %H:%M:%S",
                    time.localtime(os.path.getmtime(file_info.path))
                )

                from core.file_handler import format_size
                size = format_size(file_info.size)

                # 应用模板
                template = TEMPLATES.get(self.template, TEMPLATES["默认"])

                return template.format(
                    basename=basename,
                    relative_path=relative_path,
                    language=file_info.language.lower(),
                    size=size,
                    mtime=mtime,
                    content=content
                )

            except Exception as e:
                return f"<!-- ❌ 错误: 无法处理文件 {file_info.path}: {str(e)} -->\n\n"

    def convert_files(self,
                     files: list[FileInfo],
                     output_path: str,
                     progress_callback: Optional[Callable[[int, int, str], None]] = None) -> dict:
        """
        批量转换文件 - 性能优化版

        优化点：
        1. 使用线程池并行读取文件
        2. 使用 StringIO 优化字符串拼接
        3. 分批写入磁盘减少IO次数

        Args:
            files: 文件列表
            output_path: 输出文件路径
            progress_callback: 进度回调函数 (current, total, filename)

        Returns:
            dict: 转换结果统计
        """
        total = len(files)
        success = 0
        errors = []

        try:
            with open(output_path, 'w', encoding='utf-8', buffering=8192*16) as f:
                # 写入文档头部
                f.write(self._generate_header(files))

                # 使用 StringIO 缓冲区优化字符串拼接
                buffer = StringIO()
                buffer_count = 0

                # 使用线程池并行转换
                with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
                    # 提交所有任务
                    future_to_file = {
                        executor.submit(self.convert_file, file_info): (i, file_info)
                        for i, file_info in enumerate(files, 1)
                    }

                    # 按完成顺序处理（保持文件顺序需要排序）
                    results = {}
                    for future in as_completed(future_to_file):
                        i, file_info = future_to_file[future]

                        try:
                            markdown = future.result()
                            results[i] = markdown
                            success += 1
                        except Exception as e:
                            errors.append({
                                'file': file_info.path,
                                'error': str(e)
                            })
                            results[i] = f"<!-- ❌ 错误: {str(e)} -->\n\n"

                    # 按顺序写入结果（使用缓冲区）
                    for i in range(1, total + 1):
                        if i in results:
                            # 回调进度
                            if progress_callback:
                                progress_callback(i, total, files[i-1].name)

                            # 写入缓冲区
                            buffer.write(results[i])
                            buffer_count += 1

                            # 批量写入磁盘
                            if buffer_count >= self.chunk_size:
                                f.write(buffer.getvalue())
                                buffer.close()
                                buffer = StringIO()
                                buffer_count = 0

                    # 写入剩余缓冲区
                    if buffer_count > 0:
                        f.write(buffer.getvalue())
                        buffer.close()

                # 写入文档尾部
                f.write(self._generate_footer(success, total))

        except Exception as e:
            return {
                'success': False,
                'message': f'写入输出文件失败: {str(e)}',
                'converted': 0,
                'total': total,
                'errors': errors
            }

        return {
            'success': True,
            'message': f'成功转换 {success}/{total} 个文件',
            'converted': success,
            'total': total,
            'errors': errors
        }

    def _generate_header(self, files: list[FileInfo]) -> str:
        """生成文档头部 - 使用 join 优化"""
        from core.file_handler import format_size

        total_size = sum(f.size for f in files)
        languages = set(f.language for f in files)

        # 使用列表和 join 优化字符串拼接
        header_parts = [
            "# 代码转Markdown文档\n\n",
            f"**生成时间:** {time.strftime('%Y-%m-%d %H:%M:%S')}\n",
            f"**文件数量:** {len(files)}\n",
            f"**总大小:** {format_size(total_size)}\n",
            f"**编程语言:** {', '.join(sorted(languages))}\n",
            f"**使用模板:** {self.template}\n\n",
            "---\n\n"
        ]

        return ''.join(header_parts)

    def _generate_footer(self, success: int, total: int) -> str:
        """生成文档尾部 - 使用 join 优化"""
        footer_parts = [
            "\n\n---\n\n",
            "## 转换统计\n\n",
            f"- 成功转换: **{success}** 个文件\n",
            f"- 总计处理: **{total}** 个文件\n",
            f"- 完成时间: {time.strftime('%Y-%m-%d %H:%M:%S')}\n\n",
            "---\n\n",
            "文档生成完成\n"
        ]

        return ''.join(footer_parts)
def get_template_names() -> list[str]:
    """获取所有模板名称"""
    return list(TEMPLATES.keys())

def preview_template(template_name: str) -> str:
    """预览模板内容"""
    return TEMPLATES.get(template_name, TEMPLATES["默认"])
# core\file_handler.py

```python
"""
文件处理核心模块
"""

import os
from typing import List, Dict, Optional
from dataclasses import dataclass

# 支持的语言和扩展名
LANGUAGE_EXTENSIONS = {
    'Python': ['.py', '.pyw', '.pyi'],
    'JavaScript': ['.js', '.jsx', '.mjs'],
    'TypeScript': ['.ts', '.tsx'],
    'Java': ['.java'],
    'C': ['.c', '.h'],
    'C++': ['.cpp', '.hpp', '.cc', '.cxx'],
    'C#': ['.cs'],
    'PHP': ['.php'],
    'Ruby': ['.rb'],
    'Go': ['.go'],
    'Rust': ['.rs'],
    'Swift': ['.swift'],
    'Kotlin': ['.kt', '.kts'],
    'HTML': ['.html', '.htm'],
    'CSS': ['.css', '.scss', '.sass', '.less'],
    'SQL': ['.sql'],
    'Shell': ['.sh', '.bash', '.zsh'],
    'PowerShell': ['.ps1'],
    'YAML': ['.yml', '.yaml'],
    'JSON': ['.json'],
    'XML': ['.xml'],
    'Markdown': ['.md'],
    'Vue': ['.vue'],
    'Svelte': ['.svelte'],
    'Dart': ['.dart'],
    'R': ['.r', '.R'],
    'Lua': ['.lua'],
    'Perl': ['.pl', '.pm'],
    'Text': ['.txt']
}

@dataclass
class FileInfo:
    """文件信息数据类"""
    path: str
    marked: bool = True
    _cached_size: int = None
    _cached_mtime: float = None
    
    @property
    def name(self) -> str:
        return os.path.basename(self.path)
    
    @property
    def language(self) -> str:
        return get_language(self.path)
    
    @property
    def size(self) -> int:
        try:
            return os.path.getsize(self.path)
        except:
            return 0
    
    @property
    def exists(self) -> bool:
        return os.path.exists(self.path)
    
    @property
    def mtime(self) -> float:
        """获取文件修改时间"""
        try:
            return os.path.getmtime(self.path)
        except:
            return 0
    
    def is_modified(self) -> bool:
        """检查文件是否被修改"""
        if self._cached_mtime is None:
            self._cached_mtime = self.mtime
            return False
        return self.mtime != self._cached_mtime
    
    def update_cache(self):
        """更新缓存信息"""
        self._cached_size = self.size
        self._cached_mtime = self.mtime

class FileHandler:
    """文件处理器"""
    
    def __init__(self):
        self.files: List[FileInfo] = []
    
    def add_file(self, path: str) -> bool:
        """添加单个文件"""
        if not os.path.isfile(path):
            return False
        
        # 检查是否已存在
        if any(f.path == path for f in self.files):
            return False
        
        file_info = FileInfo(path=path, marked=True)
        file_info.update_cache()
        self.files.append(file_info)
        return True
    
    def add_files(self, paths: List[str]) -> int:
        """批量添加文件"""
        count = 0
        for path in paths:
            if self.add_file(path):
                count += 1
        return count
    
    def add_folder(self, folder_path: str, recursive: bool = True) -> int:
        """添加文件夹中的所有支持文件"""
        if not os.path.isdir(folder_path):
            return 0
        
        files = scan_folder(folder_path, recursive)
        return self.add_files(files)
    
    def remove_file(self, path: str) -> bool:
        """移除文件"""
        for i, file in enumerate(self.files):
            if file.path == path:
                self.files.pop(i)
                return True
        return False
    
    def clear(self):
        """清空所有文件"""
        self.files.clear()
    
    def toggle_mark(self, path: str) -> bool:
        """切换文件标记状态"""
        for file in self.files:
            if file.path == path:
                file.marked = not file.marked
                return file.marked
        return False
    
    def mark_all(self, marked: bool = True):
        """标记/取消标记所有文件"""
        for file in self.files:
            file.marked = marked
    
    def get_marked_files(self) -> List[FileInfo]:
        """获取所有已标记的文件"""
        return [f for f in self.files if f.marked]
    
    def get_stats(self) -> Dict:
        """获取统计信息"""
        total = len(self.files)
        marked = len(self.get_marked_files())
        total_size = sum(f.size for f in self.files)
        languages = set(f.language for f in self.files)
        
        return {
            'total': total,
            'marked': marked,
            'size': total_size,
            'languages': len(languages)
        }
    
    def filter_files(self, 
                    search: Optional[str] = None,
                    language: Optional[str] = None) -> List[FileInfo]:
        """筛选文件"""
        result = self.files
        
        if search:
            search = search.lower()
            result = [f for f in result if search in f.name.lower()]
        
        if language and language != "全部语言":
            result = [f for f in result if f.language == language]
        
        return result
    
    def refresh_files(self) -> Dict:
        """刷新所有文件，移除不存在的，更新缓存"""
        removed = []
        modified = []
        
        # 检查文件是否存在，是否被修改
        for file_info in self.files[:]:  # 使用切片创建副本进行迭代
            if not file_info.exists:
                self.files.remove(file_info)
                removed.append(file_info.path)
            else:
                if file_info.is_modified():
                    modified.append(file_info.path)
                file_info.update_cache()
        
        return {
            'removed': removed,
            'modified': modified,
            'removed_count': len(removed),
            'modified_count': len(modified)
        }

def get_language(file_path: str) -> str:
    """根据文件扩展名获取编程语言"""
    _, ext = os.path.splitext(file_path.lower())
    
    for language, extensions in LANGUAGE_EXTENSIONS.items():
        if ext in extensions:
            return language
    
    return "Text"

def get_all_languages() -> List[str]:
    """获取所有支持的语言"""
    return sorted(LANGUAGE_EXTENSIONS.keys())

def scan_folder(folder_path: str, recursive: bool = True) -> List[str]:
    """扫描文件夹获取所有支持的文件"""
    supported_files = []
    all_extensions = [ext for exts in LANGUAGE_EXTENSIONS.values() for ext in exts]
    
    if recursive:
        for root, _, files in os.walk(folder_path):
            for file in files:
                file_path = os.path.join(root, file)
                _, ext = os.path.splitext(file_path.lower())
                if ext in all_extensions:
                    supported_files.append(file_path)
    else:
        for file in os.listdir(folder_path):
            file_path = os.path.join(folder_path, file)
            if os.path.isfile(file_path):
                _, ext = os.path.splitext(file_path.lower())
                if ext in all_extensions:
                    supported_files.append(file_path)
    
    return supported_files

def format_size(size_bytes: int) -> str:
    """格式化文件大小"""
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    elif size_bytes < 1024 * 1024 * 1024:
        return f"{size_bytes / (1024 * 1024):.1f} MB"
    else:
        return f"{size_bytes / (1024 * 1024 * 1024):.1f} GB"
# core\file_watcher.py

```python
"""
文件监控模块 - 自动检测文件变化
"""

import os
import time
from typing import Callable, Dict, Set
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileModifiedEvent, FileDeletedEvent
from threading import Lock

class FileChangeHandler(FileSystemEventHandler):
    """文件变化处理器"""
    
    def __init__(self, callback: Callable, watched_files: Set[str]):
        super().__init__()
        self.callback = callback
        self.watched_files = watched_files
        self.last_modified = {}
        self.lock = Lock()
        
        # 防抖时间（秒）
        self.debounce_time = 1.0
    
    def on_modified(self, event):
        """文件被修改"""
        if event.is_directory:
            return
        
        file_path = os.path.abspath(event.src_path)
        
        # 只处理监控列表中的文件
        if file_path not in self.watched_files:
            return
        
        # 防抖处理
        with self.lock:
            current_time = time.time()
            last_time = self.last_modified.get(file_path, 0)
            
            if current_time - last_time < self.debounce_time:
                return
            
            self.last_modified[file_path] = current_time
        
        # 回调通知
        self.callback('modified', file_path)
    
    def on_deleted(self, event):
        """文件被删除"""
        if event.is_directory:
            return
        
        file_path = os.path.abspath(event.src_path)
        
        if file_path not in self.watched_files:
            return
        
        self.callback('deleted', file_path)

class FileWatcher:
    """文件监控器"""
    
    def __init__(self, callback: Callable):
        """
        初始化文件监控器
        
        Args:
            callback: 回调函数 callback(event_type, file_path)
                     event_type: 'modified' 或 'deleted'
        """
        self.callback = callback
        self.observer = Observer()
        self.watched_files: Set[str] = set()
        self.watched_dirs: Dict[str, Set[str]] = {}  # 目录 -> 该目录下监控的文件集合
        self.handler = None
        self.is_running = False
    
    def start(self):
        """启动监控"""
        if not self.is_running:
            self.handler = FileChangeHandler(self.callback, self.watched_files)
            self.observer.start()
            self.is_running = True
    
    def stop(self):
        """停止监控"""
        if self.is_running:
            self.observer.stop()
            self.observer.join(timeout=2)
            self.is_running = False
    
    def add_file(self, file_path: str):
        """添加文件到监控列表"""
        if not os.path.exists(file_path):
            return False
        
        file_path = os.path.abspath(file_path)
        dir_path = os.path.dirname(file_path)
        
        # 添加到监控文件集合
        self.watched_files.add(file_path)
        
        # 如果该目录还没有被监控，添加监控
        if dir_path not in self.watched_dirs:
            self.watched_dirs[dir_path] = set()
            # 确保 handler 已初始化
            if self.handler is None:
                self.handler = FileChangeHandler(self.callback, self.watched_files)
            try:
                self.observer.schedule(self.handler, dir_path, recursive=False)
            except Exception as e:
                print(f"监控目录失败 {dir_path}: {e}")
                return False
        
        # 记录该目录下的文件
        self.watched_dirs[dir_path].add(file_path)
        return True
    
    def remove_file(self, file_path: str):
        """从监控列表移除文件"""
        file_path = os.path.abspath(file_path)
        dir_path = os.path.dirname(file_path)
        
        # 从监控文件集合移除
        self.watched_files.discard(file_path)
        
        # 从目录映射中移除
        if dir_path in self.watched_dirs:
            self.watched_dirs[dir_path].discard(file_path)
            
            # 如果该目录下没有其他监控文件了，停止监控该目录
            if not self.watched_dirs[dir_path]:
                del self.watched_dirs[dir_path]
                # 注意: watchdog 不支持直接移除单个监控，需要重启observer
    
    def clear(self):
        """清空所有监控"""
        self.watched_files.clear()
        self.watched_dirs.clear()
        
        if self.is_running:
            self.stop()
            self.observer = Observer()
            self.handler = FileChangeHandler(self.callback, self.watched_files)
            self.start()
    
    def get_watched_count(self) -> int:
        """获取监控文件数量"""
        return len(self.watched_files)
# core\__init__.py

```python
# 核心功能包

# ui\app.py

```python
"""
主应用窗口 - 优化版（拖放降级 + 性能优化）
"""

import customtkinter as ctk
from tkinter import filedialog, messagebox
import os

# 导入拖放支持
try:
    from tkinterdnd2 import DND_FILES, TkinterDnD
    DRAG_DROP_AVAILABLE = True
except ImportError:
    DRAG_DROP_AVAILABLE = False
    print("提示: 安装 tkinterdnd2 以启用拖放功能: pip install tkinterdnd2")

from config.theme import MD
from config.settings import Settings
from core.file_handler import FileHandler
from core.converter import Converter
from core.file_watcher import FileWatcher
from ui.components.file_list_panel import FileListPanel
from ui.components.control_panel import ControlPanel
from ui.components.dialogs import TemplatePreviewDialog, ConversionPreviewDialog


# ============ 优雅降级基类 ============
class DragDropMixin:
    """拖放功能混合类 - 提供安全的降级处理"""
    
    def drop_target_register(self, *args, **kwargs):
        """安全的拖放注册"""
        if DRAG_DROP_AVAILABLE and hasattr(super(), 'drop_target_register'):
            return super().drop_target_register(*args, **kwargs)
        return None
    
    def dnd_bind(self, *args, **kwargs):
        """安全的拖放绑定"""
        if DRAG_DROP_AVAILABLE and hasattr(super(), 'dnd_bind'):
            return super().dnd_bind(*args, **kwargs)
        return None


if DRAG_DROP_AVAILABLE:
    class AppBase(DragDropMixin, TkinterDnD.Tk):
        """支持拖放的基类"""
        def __init__(self):
            TkinterDnD.Tk.__init__(self)
else:
    class AppBase(DragDropMixin, ctk.CTk):
        """不支持拖放的降级基类"""
        def __init__(self):
            ctk.CTk.__init__(self)


class MaterialApp(AppBase):
    """主应用程序 - 性能优化版"""
    
    def __init__(self):
        super().__init__()
        
        # 初始化
        self.settings = Settings()
        self.file_handler = FileHandler()
        self.converter = Converter()
        
        # 文件监控器
        self.file_watcher = FileWatcher(self._on_file_changed)
        self.watch_enabled = self.settings.get('auto_watch_files', True)
        
        # 修改文件跟踪
        self.modified_files = set()
        self.deleted_files = set()
        
        # 窗口调整防抖
        self._resize_after_id = None
        
        self._setup_window()
        self._build_ui()
        self._setup_drag_drop()
        self._load_saved_state()
        
        # 启动文件监控
        if self.watch_enabled:
            self.file_watcher.start()
        
        # 绑定关闭事件
        self.protocol("WM_DELETE_WINDOW", self._on_closing)
        self.bind('<Configure>', self._on_window_configure)
    
    def _setup_window(self):
        """设置窗口"""
        self.title("代码转Markdown工具 - 性能优化版")
        
        width = self.settings.get('window', {}).get('width', 1280)
        height = self.settings.get('window', {}).get('height', 800)
        
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        x = (screen_width - width) // 2
        y = (screen_height - height) // 2
        
        self.geometry(f"{width}x{height}+{x}+{y}")
        
        min_width = self.settings.get('window', {}).get('min_width', 1000)
        min_height = self.settings.get('window', {}).get('min_height', 600)
        self.minsize(min_width, min_height)
        
        # 统一背景色设置
        self._set_background_color()
    
    def _set_background_color(self):
        """设置背景色 - 兼容不同父类"""
        try:
            if DRAG_DROP_AVAILABLE:
                self.configure(bg=MD.BG_MAIN)
            else:
                self.configure(fg_color=MD.BG_MAIN)
        except Exception as e:
            print(f"设置背景色失败: {e}")
    
    def _setup_drag_drop(self):
        """设置拖放功能 - 安全降级"""
        if not DRAG_DROP_AVAILABLE:
            print("拖放功能不可用，已降级为文件选择模式")
            self._show_drag_drop_hint()
            return
        
        try:
            # 为主窗口注册拖放
            self.drop_target_register(DND_FILES)
            self.dnd_bind('<<Drop>>', self._on_drop)
            
            # 为文件列表面板注册拖放
            if hasattr(self, 'file_panel'):
                self.file_panel.drop_target_register(DND_FILES)
                self.file_panel.dnd_bind('<<Drop>>', self._on_drop)
            
            print("拖放功能已启用")
        except Exception as e:
            print(f"警告: 拖放功能初始化失败: {e}")
    
    def _show_drag_drop_hint(self):
        """显示拖放功能提示"""
        hint = ctk.CTkLabel(
            self,
            text="💡 提示: 安装 tkinterdnd2 启用拖放功能",
            font=MD.FONT_LABEL,
            text_color=MD.WARNING
        )
        hint.grid(row=0, column=0, columnspan=2, pady=MD.PAD_S, sticky='ew')
        self.after(5000, hint.destroy)
    
    def _on_drop(self, event):
        """处理拖放事件"""
        files = self._parse_drop_files(event.data)
        
        if not files:
            return
        
        # 异步处理拖放文件
        self._process_dropped_files_async(files)
    
    def _process_dropped_files_async(self, files):
        """异步处理拖放的文件"""
        import threading
        
        def process():
            added_files = 0
            added_folders = 0
            
            for path in files:
                if os.path.isfile(path):
                    if self.file_handler.add_file(path):
                        added_files += 1
                        if self.watch_enabled:
                            self.file_watcher.add_file(path)
                elif os.path.isdir(path):
                    count = self.file_handler.add_folder(path)
                    added_folders += count
                    if self.watch_enabled:
                        for file_info in self.file_handler.files[-count:]:
                            self.file_watcher.add_file(file_info.path)
            
            # UI更新必须在主线程
            self.after(0, lambda: self._on_drop_complete(added_files, added_folders))
        
        threading.Thread(target=process, daemon=True).start()
    
    def _on_drop_complete(self, added_files, added_folders):
        """拖放完成回调"""
        self.file_panel.refresh()
        self.control_panel.update_stats()
        
        messages = []
        if added_files > 0:
            messages.append(f"{added_files} 个文件")
        if added_folders > 0:
            messages.append(f"文件夹中的 {added_folders} 个文件")
        
        if messages:
            msg = f"已添加: {', '.join(messages)}"
            self._show_toast(msg, 'success')
        else:
            self._show_toast("没有找到支持的文件", 'warning')
    
    def _parse_drop_files(self, data):
        """解析拖放的文件路径"""
        if data.startswith('{'):
            files = []
            current = ""
            in_braces = False
            
            for char in data:
                if char == '{':
                    in_braces = True
                elif char == '}':
                    in_braces = False
                    if current:
                        files.append(current)
                        current = ""
                elif in_braces:
                    current += char
            
            return files
        else:
            return data.split()
    
    def _on_file_changed(self, event_type: str, file_path: str):
        """文件变化回调"""
        if event_type == 'modified':
            self.modified_files.add(file_path)
            self._show_file_change_notification()
        elif event_type == 'deleted':
            self.deleted_files.add(file_path)
            self._show_file_change_notification()
    
    def _show_file_change_notification(self):
        """显示文件变化通知"""
        modified_count = len(self.modified_files)
        deleted_count = len(self.deleted_files)
        
        messages = []
        if modified_count > 0:
            messages.append(f"{modified_count} 个文件已修改")
        if deleted_count > 0:
            messages.append(f"{deleted_count} 个文件已删除")
        
        if messages:
            msg = "检测到文件变化: " + ", ".join(messages)
            
            if not hasattr(self, 'notification_bar') or not self.notification_bar.winfo_exists():
                self._create_notification_bar(msg)
            else:
                self.notification_label.configure(text=msg)
    
    def _create_notification_bar(self, message: str):
        """创建通知栏"""
        self.notification_bar = ctk.CTkFrame(
            self,
            fg_color=MD.WARNING_CONTAINER,
            height=50
        )
        self.notification_bar.grid(row=0, column=0, columnspan=2, sticky='ew',
                                   padx=MD.PAD_M, pady=(MD.PAD_M, 0))

        content = ctk.CTkFrame(self.notification_bar, fg_color='transparent')
        content.grid(row=0, column=0, sticky='nsew', padx=MD.PAD_M, pady=MD.PAD_S)
        self.notification_bar.grid_columnconfigure(0, weight=1)
        self.notification_bar.grid_rowconfigure(0, weight=1)

        self.notification_label = ctk.CTkLabel(
            content,
            text=message,
            font=MD.FONT_BODY,
            text_color=MD.ON_SURFACE
        )
        self.notification_label.grid(row=0, column=0, sticky='w', padx=(0, MD.PAD_M))

        button_frame = ctk.CTkFrame(content, fg_color='transparent')
        button_frame.grid(row=0, column=1, sticky='e')

        ctk.CTkButton(
            button_frame,
            text="刷新",
            command=self._refresh_changed_files,
            fg_color=MD.PRIMARY,
            hover_color=MD.PRIMARY_CONTAINER,
            width=80,
            height=32
        ).grid(row=0, column=0, padx=(0, MD.PAD_S))

        ctk.CTkButton(
            button_frame,
            text="关闭",
            command=self._close_notification,
            fg_color='transparent',
            hover_color=MD.BG_SURFACE,
            width=32,
            height=32
        ).grid(row=0, column=1)
    
    def _refresh_changed_files(self):
        """刷新变化的文件"""
        for file_path in self.deleted_files:
            self.file_handler.remove_file(file_path)
            self.file_watcher.remove_file(file_path)
        
        for file_path in self.modified_files:
            for file_info in self.file_handler.files:
                if file_info.path == file_path:
                    file_info.update_cache()
                    break
        
        self.file_panel.refresh()
        self.control_panel.update_stats()
        
        modified_count = len(self.modified_files)
        deleted_count = len(self.deleted_files)
        self.modified_files.clear()
        self.deleted_files.clear()
        
        self._close_notification()
        
        msg = f"已刷新: {modified_count} 个修改, {deleted_count} 个删除"
        self._show_toast(msg, 'success')
    
    def _close_notification(self):
        """关闭通知栏"""
        if hasattr(self, 'notification_bar') and self.notification_bar.winfo_exists():
            self.notification_bar.destroy()
        
        self.modified_files.clear()
        self.deleted_files.clear()
    
    def _build_ui(self):
        """构建UI"""
        self.grid_columnconfigure(0, weight=3)
        self.grid_columnconfigure(1, weight=1)
        self.grid_rowconfigure(0, weight=1)
        self.grid_rowconfigure(1, weight=0)  # 为toast通知预留空间
        
        self.file_panel = FileListPanel(self, self.file_handler)
        self.file_panel.grid(row=0, column=0, sticky='nsew', 
                           padx=(MD.PAD_M, MD.PAD_S), 
                           pady=MD.PAD_M)
        
        self.control_panel = ControlPanel(self, self.file_handler)
        self.control_panel.grid(row=0, column=1, sticky='nsew',
                              padx=(MD.PAD_S, MD.PAD_M),
                              pady=MD.PAD_M)
        
        self.file_panel.set_update_callback(self._on_file_update)
        self.file_panel.set_file_add_callback(self._on_files_added_to_list)
        self.control_panel.set_preview_callback(self._on_preview)
        self.control_panel.set_convert_callback(self._on_convert)
        
        # 注册拖放（延迟到UI构建完成后）
        if DRAG_DROP_AVAILABLE:
            self.after(100, self._setup_drag_drop)
        
        self.toast_label = None
    
    def _on_files_added_to_list(self, file_paths: list):
        """文件添加到列表的回调"""
        if not self.watch_enabled:
            return
        
        for file_path in file_paths:
            self.file_watcher.add_file(file_path)
    
    def _on_window_configure(self, event):
        """窗口调整事件"""
        if event.widget != self:
            return
        
        if self._resize_after_id:
            self.after_cancel(self._resize_after_id)
        
        self._resize_after_id = self.after(100, self._handle_resize)
    
    def _handle_resize(self):
        """处理窗口调整"""
        self._resize_after_id = None
        self.update_idletasks()
    
    def _on_file_update(self, message: str, type: str = 'info'):
        """文件更新回调"""
        self.control_panel.update_stats()
        self._show_toast(message, type)
    
    def _on_preview(self, preview_type: str, data):
        """预览回调"""
        if preview_type == 'template':
            TemplatePreviewDialog(self, data)
        
        elif preview_type == 'conversion':
            template = self.control_panel.get_template()
            max_files = self.settings.get('preview_max_files', 5)
            ConversionPreviewDialog(self, data, template, max_files)
        
        elif preview_type == 'warning':
            self._show_toast(f"警告: {data}", 'warning')
    
    def _on_convert(self, action: str, data):
        """转换回调"""
        if action == 'warning':
            self._show_toast(f"警告: {data}", 'warning')
            return
        
        if action == 'start':
            self._perform_conversion(data)
    
    def _perform_conversion(self, files):
        """执行转换 - 异步优化"""
        output_file = filedialog.asksaveasfilename(
            title="保存 Markdown 文件",
            defaultextension=".md",
            filetypes=[("Markdown 文件", "*.md"), ("所有文件", "*.*")]
        )
        
        if not output_file:
            return
        
        self.control_panel.show_progress()
        
        template = self.control_panel.get_template()
        self.converter.set_template(template)
        
        # 异步转换
        import threading
        
        def convert_thread():
            def progress_callback(current, total, filename):
                self.after(0, lambda: self.control_panel.update_progress(current, total, filename))
            
            result = self.converter.convert_files(files, output_file, progress_callback)
            self.after(0, lambda: self._on_conversion_complete(result, output_file))
        
        threading.Thread(target=convert_thread, daemon=True).start()
    
    def _on_conversion_complete(self, result, output_file):
        """转换完成回调"""
        self.after(1000, self.control_panel.hide_progress)
        
        if result['success']:
            self._show_toast(f"成功: {result['message']}", 'success')
            messagebox.showinfo(
                "转换完成",
                f"{result['message']}\n\n保存位置: {output_file}"
            )
        else:
            self._show_toast(f"错误: {result['message']}", 'error')
            messagebox.showerror("转换失败", result['message'])
    
    def _show_toast(self, message: str, type: str = 'info'):
        """显示通知消息"""
        colors = {
            'success': MD.SUCCESS,
            'error': MD.ERROR,
            'warning': MD.WARNING,
            'info': MD.INFO
        }

        color = colors.get(type, MD.INFO)

        if self.toast_label:
            self.toast_label.destroy()

        self.toast_label = ctk.CTkLabel(
            self,
            text=message,
            font=MD.FONT_BODY,
            fg_color=color,
            text_color=MD.ON_PRIMARY,
            corner_radius=MD.RADIUS_MEDIUM,
            height=48
        )

        # 使用grid布局，但需要特殊处理，因为toast应该浮动在其他内容之上
        self.toast_label.grid(row=1, column=0, columnspan=2, pady=(0, MD.PAD_M), sticky='ew')
        self.toast_label.lift()  # 确保显示在最上层

        self.after(3000, lambda: self.toast_label.destroy() if self.toast_label else None)
    
    def _load_saved_state(self):
        """加载保存的状态"""
        recent_files = self.settings.get('recent_files', [])
        for file_path in recent_files:
            if os.path.exists(file_path):
                self.file_handler.add_file(file_path)
                if self.watch_enabled:
                    self.file_watcher.add_file(file_path)
        
        self.file_panel.refresh()
        self.control_panel.update_stats()
    
    def _save_state(self):
        """保存状态"""
        geometry = self.geometry().split('+')[0]
        width, height = map(int, geometry.split('x'))
        
        self.settings.set('window', {
            'width': width,
            'height': height,
            'min_width': 1000,
            'min_height': 600
        })
        
        max_recent = self.settings.get('max_recent_files', 50)
        recent_files = [f.path for f in self.file_handler.files[:max_recent]]
        self.settings.set('recent_files', recent_files)
        
        self.settings.set('template', self.control_panel.get_template())
        
        self.settings.save()
    
    def _on_closing(self):
        """关闭窗口"""
        if self.watch_enabled:
            self.file_watcher.stop()
        
        if self.settings.get('auto_save_config', True):
            self._save_state()
        
        self.destroy()
# ui\__init__.py

```python
# 用户界面包

# ui\components\control_panel.py

```python
"""
控制面板组件 - 使用可滚动容器避免按钮消失
"""

import customtkinter as ctk
import tkinter as tk
from config.theme import MD
from ui.widgets.material_card import Card, Btn
from core.converter import get_template_names, Converter
from core.file_handler import FileHandler, format_size

class ControlPanel(Card):
    """控制面板"""

    def __init__(self, master, file_handler: FileHandler, **kwargs):
        super().__init__(master, **kwargs)
        
        self.file_handler = file_handler
        self.converter = Converter()
        
        self.on_preview_callback = None
        self.on_convert_callback = None
        
        self._build_ui()
    
    def _build_ui(self):
        """构建UI - 使用可滚动框架"""
        # 创建可滚动容器以避免内容被遮挡
        scrollable_container = ctk.CTkScrollableFrame(
            self,
            fg_color='transparent'
        )
        scrollable_container.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_M)
        
        # 标题
        self._build_header(scrollable_container)
        
        # 模板选择
        self._build_template_section(scrollable_container)
        
        # 统计卡片
        self._build_stats_section(scrollable_container)
        
        # 操作按钮（放在可滚动区域内，确保始终可访问）
        self._build_actions(scrollable_container)
        
        # 进度显示（固定在底部）
        self._build_progress()
    
    def _build_header(self, parent):
        """构建标题"""
        header = ctk.CTkFrame(parent, fg_color='transparent')
        header.pack(fill='x', pady=(0, MD.PAD_M))
        
        title_container = ctk.CTkFrame(header, fg_color='transparent')
        title_container.pack(anchor='w')
        
        ctk.CTkLabel(
            title_container,
            text="转换设置",
            font=MD.FONT_HEADLINE,
            text_color=MD.ON_SURFACE
        ).pack(side='left')
        
        ctk.CTkLabel(
            title_container,
            text="⚙️",
            font=("Segoe UI Emoji", 24)
        ).pack(side='left', padx=(MD.PAD_S, 0))
    
    def _build_template_section(self, parent):
        """构建模板选择区域"""
        section = Card(parent, fg_color=MD.BG_SURFACE)
        section.pack(fill='x', pady=(0, MD.PAD_M))
        
        section_container = ctk.CTkFrame(section, fg_color='transparent')
        section_container.pack(fill='both', padx=MD.PAD_M, pady=MD.PAD_M)
        
        # 标题
        ctk.CTkLabel(
            section_container,
            text="Markdown 模板",
            font=MD.FONT_TITLE,
            text_color=MD.TEXT_PRIMARY,
            anchor='w'
        ).pack(fill='x', pady=(0, MD.PAD_S))
        
        # 模板选择下拉框
        self.template_var = tk.StringVar(value="默认")
        template_combo = ctk.CTkComboBox(
            section_container,
            values=get_template_names(),
            variable=self.template_var,
            state='readonly',
            fg_color=MD.BG_SURFACE,
            button_color=MD.ACCENT_BLUE,
            border_color=MD.BORDER,
            font=MD.FONT_UI,
            command=self._on_template_changed
        )
        template_combo.pack(fill='x', pady=(0, MD.PAD_S))
        
        # 预览按钮
        Btn(
            section_container,
            text="预览模板",
            command=self._preview_template,
            kind='normal',
            width=200
        ).pack(fill='x')
    
    def _build_stats_section(self, parent):
        """构建统计区域"""
        # 底部状态栏一行显示所有统计
        self.stats = ctk.CTkLabel(
            self,
            text="0/0 文件  •  0 B  •  0 语言",
            font=MD.FONT_UI,
            text_color=MD.TEXT_SECONDARY,
            anchor='w'
        )
        self.stats.pack(fill='x', padx=MD.PAD_M, pady=MD.PAD_S)
    
    def _build_actions(self, parent):
        """构建操作按钮 - 现在在滚动区域内"""
        actions = ctk.CTkFrame(parent, fg_color='transparent')
        actions.pack(fill='x', pady=(MD.PAD_M, MD.PAD_M))
        
        Btn(
            actions,
            text="预览转换结果",
            command=self._preview_conversion,
            kind='normal',
            height=48
        ).pack(fill='x', pady=(0, MD.PAD_M))

        Btn(
            actions,
            text="开始转换",
            command=self._start_conversion,
            kind='primary',
            height=56,
            font=MD.FONT_UI
        ).pack(fill='x')
        
        # 添加一些底部空间，确保按钮不会紧贴底部
        ctk.CTkFrame(parent, fg_color='transparent', height=20).pack()
    
    def _build_progress(self):
        """构建进度显示 - 固定在窗口底部"""
        # 在主卡片底部创建固定的进度容器
        self.progress_container = ctk.CTkFrame(self, fg_color=MD.BG_SURFACE, height=60)
        
        progress_content = ctk.CTkFrame(self.progress_container, fg_color='transparent')
        progress_content.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_S)
        
        self.progress_bar = ctk.CTkProgressBar(
            progress_content,
            height=8,
            corner_radius=4,
            fg_color=MD.BG_SURFACE,
            progress_color=MD.ACCENT_BLUE
        )
        self.progress_bar.pack(fill='x', pady=(0, MD.PAD_S))
        
        self.progress_label = ctk.CTkLabel(
            progress_content,
            text="",
            font=MD.FONT_UI,
            text_color=MD.TEXT_SECONDARY
        )
        self.progress_label.pack()
        
        # 初始隐藏
        self.hide_progress()
    
    # 事件处理
    def _on_template_changed(self, template_name):
        """模板改变事件"""
        self.converter.set_template(template_name)
    
    def _preview_template(self):
        """预览模板"""
        if self.on_preview_callback:
            self.on_preview_callback('template', self.template_var.get())
    
    def _preview_conversion(self):
        """预览转换"""
        marked_files = self.file_handler.get_marked_files()
        
        if not marked_files:
            if self.on_preview_callback:
                self.on_preview_callback('warning', '请先选择要预览的文件')
            return
        
        if self.on_preview_callback:
            self.on_preview_callback('conversion', marked_files)
    
    def _start_conversion(self):
        """开始转换"""
        marked_files = self.file_handler.get_marked_files()
        
        if not marked_files:
            if self.on_convert_callback:
                self.on_convert_callback('warning', '请先选择要转换的文件')
            return
        
        if self.on_convert_callback:
            self.on_convert_callback('start', marked_files)
    
    def update_stats(self):
        """更新统计信息"""
        stats = self.file_handler.get_stats()
        self.stats.configure(
            text=f"{stats['marked']}/{stats['total']} 文件  •  "
                 f"{format_size(stats['size'])}  •  "
                 f"{stats['languages']} 语言"
        )
    
    def show_progress(self):
        """显示进度条"""
        self.progress_container.pack(side='bottom', fill='x', padx=MD.PAD_M, pady=(0, MD.PAD_M))
        self.progress_bar.set(0)
    
    def hide_progress(self):
        """隐藏进度条"""
        self.progress_container.pack_forget()
    
    def update_progress(self, current: int, total: int, filename: str = ""):
        """更新进度"""
        progress = current / total if total > 0 else 0
        self.progress_bar.set(progress)
        
        # 截断过长的文件名
        if len(filename) > 30:
            filename = "..." + filename[-27:]
        
        self.progress_label.configure(
            text=f"正在处理: {filename} ({current}/{total})"
        )
    
    def set_preview_callback(self, callback):
        """设置预览回调"""
        self.on_preview_callback = callback
    
    def set_convert_callback(self, callback):
        """设置转换回调"""
        self.on_convert_callback = callback
    
    def get_template(self) -> str:
        """获取当前模板"""
        return self.template_var.get()
# ui\components\dialogs.py

```python
"""
对话框组件
"""

import customtkinter as ctk
from config.theme import MD
from ui.widgets.material_card import Btn
from core.converter import preview_template, Converter
from core.file_handler import FileInfo

class PreviewDialog(ctk.CTkToplevel):
    """预览对话框基类"""
    
    def __init__(self, parent, title: str, width: int = 800, height: int = 600):
        super().__init__(parent)
        
        self.title(title)
        self.geometry(f"{width}x{height}")
        self.configure(fg_color=MD.BG_MAIN)
        
        # 居中显示
        self.update_idletasks()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")
        
        # 模态
        self.transient(parent)
        self.grab_set()
    
    def _build_header(self, title: str, subtitle: str = ""):
        """构建头部"""
        header = ctk.CTkFrame(self, fg_color=MD.SURFACE_1, height=80)
        header.pack(fill='x', padx=MD.PAD_M, pady=MD.PAD_M)
        header.pack_propagate(False)
        
        header_content = ctk.CTkFrame(header, fg_color='transparent')
        header_content.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_M)
        
        ctk.CTkLabel(
            header_content,
            text=title,
            font=MD.FONT_HEADLINE,
            text_color=MD.ON_SURFACE
        ).pack(anchor='w')
        
        if subtitle:
            ctk.CTkLabel(
                header_content,
                text=subtitle,
                font=MD.FONT_BODY,
                text_color=MD.ON_SURFACE_VARIANT
            ).pack(anchor='w', pady=(MD.SPACING_XS, 0))
        
        return header
    
    def _build_content_area(self):
        """构建内容区域"""
        content = ctk.CTkFrame(self, fg_color=MD.SURFACE)
        content.pack(fill='both', expand=True, padx=MD.PAD_M, pady=(0, MD.PAD_M))
        
        textbox = ctk.CTkTextbox(
            content,
            font=MD.FONT_MONO,
            fg_color=MD.SURFACE,
            text_color=MD.ON_SURFACE,
            wrap='none'
        )
        textbox.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_M)
        
        return textbox
    
    def _build_footer(self):
        """构建底部按钮"""
        footer = ctk.CTkFrame(self, fg_color='transparent')
        footer.pack(fill='x', padx=MD.PAD_M, pady=(0, MD.PAD_M))
        
        Btn(
            footer,
            kind='normal',
            text="关闭",
            command=self.destroy,
            width=120
        ).pack(side='right')
        
        return footer

class TemplatePreviewDialog(PreviewDialog):
    """模板预览对话框"""
    
    def __init__(self, parent, template_name: str):
        super().__init__(parent, f"模板预览 - {template_name}", 700, 500)
        
        self._build_header(
            f"{template_name} 模板",
            "查看模板的格式和结构"
        )
        
        textbox = self._build_content_area()
        
        # 显示模板内容
        template_content = preview_template(template_name)
        textbox.insert('1.0', template_content)
        textbox.configure(state='disabled')
        
        self._build_footer()

class ConversionPreviewDialog(PreviewDialog):
    """转换预览对话框"""
    
    def __init__(self, parent, files: list[FileInfo], template: str, max_files: int = 5):
        super().__init__(parent, "转换预览", 900, 700)
        
        self._build_header(
            f"👁️ 转换预览",
            f"使用 {template} 模板  •  预览前 {min(len(files), max_files)} 个文件"
        )
        
        textbox = self._build_content_area()
        
        # 生成预览内容
        converter = Converter(template)
        preview_content = []
        
        for i, file_info in enumerate(files[:max_files]):
            preview_content.append(converter.convert_file(file_info))
        
        if len(files) > max_files:
            preview_content.append(
                f"\n{'='*80}\n"
                f"... 还有 {len(files) - max_files} 个文件未在预览中显示 ...\n"
                f"{'='*80}\n"
            )
        
        textbox.insert('1.0', ''.join(preview_content))
        textbox.configure(state='disabled')
        
        self._build_footer()
# ui\components\file_list_panel.py

```python
"""
文件列表面板组件 - 性能优化版本
"""

import customtkinter as ctk
import tkinter as tk
from tkinter import filedialog, ttk
from config.theme import MD
from ui.widgets.material_card import Card, Btn
from core.file_handler import FileHandler, get_all_languages, format_size
import os
from pathlib import Path
import threading

class FileListPanel(Card):
    """文件列表面板"""
    
    def __init__(self, master, file_handler: FileHandler, **kwargs):
        super().__init__(master, **kwargs)
        
        self.file_handler = file_handler
        self.on_update_callback = None
        self.on_file_add_callback = None
        self._refresh_pending = False
        self._loading = False
        self._loading_animation_id = None
        self._update_lock = False  # 添加更新锁

        self._build_ui()
    
    def _build_ui(self):
        """构建UI"""
        # 主容器
        container = ctk.CTkFrame(self, fg_color='transparent')
        container.pack(fill='both', expand=True, padx=MD.PAD_M, pady=MD.PAD_M)
        
        # 标题栏
        self._build_header(container)
        
        # 搜索和筛选栏
        self._build_search_bar(container)
        
        # 操作按钮栏
        self._build_action_bar(container)
        
        # 文件列表（树状视图）
        self._build_file_list(container)
        
        # 底部统计
        self._build_footer(container)
    
    def _build_header(self, parent):
        """构建标题栏"""
        header = ctk.CTkFrame(parent, fg_color='transparent')
        header.pack(fill='x', pady=(0, MD.PAD_M))
        
        # 标题
        title_container = ctk.CTkFrame(header, fg_color='transparent')
        title_container.pack(side='left')
        
        ctk.CTkLabel(
            title_container,
            text="文件管理",
            font=MD.FONT_HEADLINE,
            text_color=MD.ON_SURFACE
        ).pack(side='left')
        
        ctk.CTkLabel(
            title_container,
            text="📂",
            font=("Segoe UI Emoji", 16)
        ).pack(side='left', padx=(MD.PAD_S, 0))
        
        # 加载指示器容器
        self.loading_container = ctk.CTkFrame(header, fg_color=MD.BG_SURFACE, corner_radius=MD.RADIUS)
        
        # 加载进度条（不确定模式）
        self.loading_progress = ctk.CTkProgressBar(
            self.loading_container,
            height=6,
            corner_radius=3,
            fg_color=MD.SURFACE,
            progress_color=MD.PRIMARY,
            mode='indeterminate'
        )
        self.loading_progress.pack(padx=MD.PAD_M, pady=(MD.PAD_S, MD.PAD_S))
        
        # 加载文本
        self.loading_label = ctk.CTkLabel(
            self.loading_container,
            text="加载中...",
            font=MD.FONT_BODY,
            text_color=MD.PRIMARY
        )
        self.loading_label.pack(padx=MD.PAD_M, pady=(0, MD.PAD_S))
    
    def _build_search_bar(self, parent):
        """构建搜索栏"""
        search_bar = ctk.CTkFrame(parent, fg_color='transparent')
        search_bar.pack(fill='x', pady=(0, MD.PAD_M))
        
        # 搜索框
        self.search_var = tk.StringVar()
        self.search_var.trace('w', lambda *args: self._schedule_refresh())
        
        search_entry = ctk.CTkEntry(
            search_bar,
            textvariable=self.search_var,
            placeholder_text="🔍 搜索文件名...",
            width=300,
            fg_color=MD.BG_SURFACE,
            border_color=MD.BORDER,
            corner_radius=MD.RADIUS
        )
        search_entry.pack(side='left', fill='x', expand=True, padx=(0, MD.PAD_S))
        
        # 语言筛选
        self.language_var = tk.StringVar(value="全部语言")
        self.language_var.trace('w', lambda *args: self._schedule_refresh())
        
        languages = ["全部语言"] + get_all_languages()
        language_combo = ctk.CTkComboBox(
            search_bar,
            values=languages,
            variable=self.language_var,
            state='readonly',
            width=150,
            fg_color=MD.BG_SURFACE,
            button_color=MD.PRIMARY,
            border_color=MD.OUTLINE,
            font=MD.FONT_BODY
        )
        language_combo.pack(side='left')
    
    def _build_action_bar(self, parent):
        """构建操作按钮栏"""
        action_bar = ctk.CTkFrame(parent, fg_color='transparent')
        action_bar.pack(fill='x', pady=(0, MD.PAD_M))
        
        action_bar.grid_columnconfigure(0, weight=1)
        action_bar.grid_columnconfigure(1, weight=0)
        
        # 左侧按钮容器
        left_buttons = ctk.CTkFrame(action_bar, fg_color='transparent')
        left_buttons.grid(row=0, column=0, sticky='w', padx=(0, MD.PAD_S))
        
        Btn(
            left_buttons,
            kind='primary',
            text="➕ 文件",
            command=self._add_files,
            width=100
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            left_buttons,
            kind='primary',
            text="文件夹",
            command=self._add_folder,
            width=100
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            left_buttons,
            kind='normal',
            text="刷新",
            command=self._refresh_files,
            width=50
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            left_buttons,
            kind='danger',
            text="清除所有",
            command=self._clear_files,
            width=50
        ).pack(side='left')
        
        # 右侧按钮容器
        right_buttons = ctk.CTkFrame(action_bar, fg_color='transparent')
        right_buttons.grid(row=0, column=1, sticky='e')
        
        Btn(
            right_buttons,
            kind='normal',
            text="全选",
            command=lambda: self._mark_all(True),
            width=60
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            right_buttons,
            kind='normal',
            text="全不选",
            command=lambda: self._mark_all(False),
            width=70
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            right_buttons,
            kind='normal',
            text="展开",
            command=self._expand_all,
            width=60
        ).pack(side='left', padx=(0, MD.PAD_S))
        
        Btn(
            right_buttons,
            kind='normal',
            text="折叠",
            command=self._collapse_all,
            width=60
        ).pack(side='left')
    
    def _build_file_list(self, parent):
        """构建文件列表（树状视图）- 性能优化版"""
        # 列表容器
        list_container = ctk.CTkFrame(parent, fg_color=MD.SURFACE)
        list_container.pack(fill='both', expand=True, pady=(0, MD.PAD_M))
        
        # 创建样式
        style = ttk.Style()
        style.theme_use('clam')
        
        # 配置 Treeview 样式
        style.configure(
            "Compact.Treeview",
            background=MD.BG_SURFACE,
            foreground=MD.TEXT_PRIMARY,
            fieldbackground=MD.BG_SURFACE,
            borderwidth=0,
            font=MD.FONT_UI,
            rowheight=18
        )
        
        style.configure(
            "Compact.Treeview.Heading",
            background=MD.BG_ELEVATED,
            foreground=MD.TEXT_PRIMARY,
            borderwidth=1,
            relief="flat",
            font=MD.FONT_TITLE
        )

        style.map(
            "Compact.Treeview",
            background=[('selected', MD.BG_ELEVATED)],
            foreground=[('selected', MD.TEXT_PRIMARY)]
        )

        # 创建 Treeview
        columns = ('status', 'language', 'size')
        self.file_tree = ttk.Treeview(
            list_container,
            columns=columns,
            show='tree headings',
            style="Compact.Treeview",
            selectmode='browse'
        )
        
        # 配置列
        self.file_tree.column('#0', width=400, minwidth=180, stretch=True)
        self.file_tree.column('status', width=50, minwidth=50, anchor='center', stretch=False)
        self.file_tree.column('language', width=80, minwidth=70, anchor='center', stretch=False)
        self.file_tree.column('size', width=70, minwidth=70, anchor='e', stretch=False)

        # 设置列标题
        self.file_tree.heading('#0', text='[+] 文件路径', anchor='w')
        self.file_tree.heading('status', text='状态', anchor='center')
        self.file_tree.heading('language', text='语言', anchor='center')
        self.file_tree.heading('size', text='大小', anchor='e')
        
        # 滚动条
        vsb = ttk.Scrollbar(list_container, orient="vertical", command=self.file_tree.yview)
        self.file_tree.configure(yscrollcommand=vsb.set)
        
        # 布局
        self.file_tree.grid(row=0, column=0, sticky='nsew')
        vsb.grid(row=0, column=1, sticky='ns')
        
        list_container.grid_rowconfigure(0, weight=1)
        list_container.grid_columnconfigure(0, weight=1)
        
        # 绑定事件
        self.file_tree.bind('<Double-Button-1>', self._on_item_double_click)
        self.file_tree.bind('<space>', self._on_space_press)
        self.file_tree.bind('<Button-1>', self._on_item_click)
        
        # 存储节点映射
        self.item_to_path = {}
        self.path_to_item = {}
    
    def _build_footer(self, parent):
        """构建底部统计"""
        footer = ctk.CTkFrame(parent, fg_color='transparent')
        footer.pack(fill='x')
        
        self.stats_label = ctk.CTkLabel(
            footer,
            text="0 个文件",
            font=MD.FONT_BODY,
            text_color=MD.ON_SURFACE_VARIANT
        )
        self.stats_label.pack(side='left')
    
    # 事件处理
    def _add_files(self):
        """添加文件"""
        filetypes = [
            ("所有支持的文件", "*.py *.js *.java *.cpp *.html *.css"),
            ("所有文件", "*.*")
        ]
        
        files = filedialog.askopenfilenames(title="选择代码文件", filetypes=filetypes)
        
        if files:
            self._show_loading(True)
            def add_files_thread():
                count = self.file_handler.add_files(list(files))
                self.after(0, lambda: self._on_files_added(count))
            
            thread = threading.Thread(target=add_files_thread, daemon=True)
            thread.start()
    
    def _on_files_added(self, count):
        """文件添加完成回调"""
        self._show_loading(False)
        self.refresh()

        # 调用文件添加回调，传递新添加的文件路径
        if self.on_file_add_callback and count > 0:
            added_files = [f.path for f in self.file_handler.files[-count:]]
            self.on_file_add_callback(added_files)

        if self.on_update_callback:
            self.on_update_callback(f"✅ 成功添加了 {count} 个文件", 'success')
    
    def _add_folder(self):
        """添加文件夹"""
        folder = filedialog.askdirectory(title="选择文件夹")
        
        if folder:
            self._show_loading(True)
            def add_folder_thread():
                count = self.file_handler.add_folder(folder)
                self.after(0, lambda: self._on_folder_added(count))
            
            thread = threading.Thread(target=add_folder_thread, daemon=True)
            thread.start()
    
    def _on_folder_added(self, count):
        """文件夹添加完成回调"""
        self._show_loading(False)
        self.refresh()

        # 调用文件添加回调，传递新添加的文件路径
        if self.on_file_add_callback and count > 0:
            added_files = [f.path for f in self.file_handler.files[-count:]]
            self.on_file_add_callback(added_files)

        if self.on_update_callback:
            self.on_update_callback(f"✅ 成功从文件夹添加了 {count} 个文件", 'success')
    
    def _refresh_files(self):
        """刷新文件列表"""
        if self._loading:
            return
        
        self._show_loading(True)
        
        def refresh_thread():
            result = self.file_handler.refresh_files()
            self.after(0, lambda: self._on_files_refreshed(result))
        
        thread = threading.Thread(target=refresh_thread, daemon=True)
        thread.start()
    
    def _on_files_refreshed(self, result):
        """文件刷新完成回调"""
        self._show_loading(False)
        self.refresh()
        
        removed_count = result['removed_count']
        modified_count = result['modified_count']
        
        messages = []
        if removed_count > 0:
            messages.append(f"移除了 {removed_count} 个不存在的文件")
        if modified_count > 0:
            messages.append(f"检测到 {modified_count} 个文件已修改")
        
        if messages:
            message = "🔄 刷新完成: " + ", ".join(messages)
        else:
            message = "🔄 刷新完成，所有文件都是最新的"
        
        if self.on_update_callback:
            self.on_update_callback(message, 'success')
    
    def _clear_files(self):
        """清空文件"""
        if not self.file_handler.files:
            return
        
        from tkinter import messagebox
        if messagebox.askyesno("确认清空", "确定要清空所有文件吗？"):
            self.file_handler.clear()
            self.refresh()
            
            if self.on_update_callback:
                self.on_update_callback("🗑️ 已清空文件列表", 'info')
    
    def _mark_all(self, marked: bool):
        """全选/全不选"""
        self.file_handler.mark_all(marked)
        self.refresh()
        
        if self.on_update_callback:
            msg = "✅ 已全选" if marked else "⬜ 已取消全选"
            self.on_update_callback(msg, 'info')
    
    def _expand_all(self):
        """展开所有节点"""
        def expand_recursive(item):
            self.file_tree.item(item, open=True)
            for child in self.file_tree.get_children(item):
                expand_recursive(child)
        
        for item in self.file_tree.get_children():
            expand_recursive(item)
    
    def _collapse_all(self):
        """折叠所有节点"""
        def collapse_recursive(item):
            self.file_tree.item(item, open=False)
            for child in self.file_tree.get_children(item):
                collapse_recursive(child)
        
        for item in self.file_tree.get_children():
            collapse_recursive(item)
    
    def _schedule_refresh(self):
        """延迟刷新（防抖）- 优化版"""
        if self._refresh_pending:
            return
        
        self._refresh_pending = True
        # 增加延迟时间，减少刷新频率
        self.after(500, self._execute_refresh)  # 从300ms改为500ms
    
    def _execute_refresh(self):
        """执行刷新"""
        self._refresh_pending = False
        self._filter_files()
    
    def _filter_files(self):
        """筛选文件"""
        search = self.search_var.get()
        language = self.language_var.get()
        
        filtered = self.file_handler.filter_files(
            search=search if search else None,
            language=language if language != "全部语言" else None
        )
        
        self._display_files(filtered)
    
    def _on_item_click(self, event):
        """单击项目"""
        item = self.file_tree.identify('item', event.x, event.y)
        if item and item in self.item_to_path:
            file_path = self.item_to_path[item]
            self._toggle_mark(file_path)
    
    def _on_item_double_click(self, event):
        """双击项目"""
        item = self.file_tree.selection()
        if item:
            if self.file_tree.get_children(item[0]):
                current_state = self.file_tree.item(item[0], 'open')
                self.file_tree.item(item[0], open=not current_state)
    
    def _on_space_press(self, event):
        """空格键切换标记"""
        item = self.file_tree.selection()
        if item and item[0] in self.item_to_path:
            file_path = self.item_to_path[item[0]]
            self._toggle_mark(file_path)
    
    def _toggle_mark(self, file_path: str):
        """切换文件标记状态"""
        self.file_handler.toggle_mark(file_path)
        self.refresh()
    
    def _build_tree_structure(self, files):
        """构建树状结构"""
        tree_dict = {}
        
        for file_info in files:
            path = Path(file_info.path)
            parts = path.parts
            
            current = tree_dict
            for i, part in enumerate(parts[:-1]):
                if part not in current:
                    current[part] = {}
                current = current[part]
            
            filename = parts[-1]
            current[filename] = file_info
        
        return tree_dict
    
    def _insert_tree_recursive(self, parent_item, tree_dict, prefix=""):
        """递归插入树节点"""
        for name, value in sorted(tree_dict.items()):
            if isinstance(value, dict):
                folder_item = self.file_tree.insert(
                    parent_item,
                    'end',
                    text=f"[+] {name}",
                    values=('', '', ''),
                    open=True
                )
                self._insert_tree_recursive(folder_item, value, prefix + name + os.sep)
            else:
                file_info = value
                icon = "[x]" if file_info.marked else "[ ]"

                file_item = self.file_tree.insert(
                    parent_item,
                    'end',
                    text=f" {name}",
                    values=(icon, file_info.language, format_size(file_info.size)),
                    tags=('file',)
                )
                
                self.item_to_path[file_item] = file_info.path
                self.path_to_item[file_info.path] = file_item
    
    def _display_files(self, files):
        """显示文件列表 - 性能优化版（消除撕裂）"""
        # 防止重复更新
        if self._update_lock:
            return
        
        self._update_lock = True
        
        try:
            # 1. 暂停UI更新
            self.file_tree.configure(selectmode='none')
            
            # 2. 批量删除（使用detach而非delete可以更快）
            children = self.file_tree.get_children()
            if children:
                self.file_tree.delete(*children)  # 批量删除
            
            self.item_to_path.clear()
            self.path_to_item.clear()
            
            if not files:
                # 空状态
                self.file_tree.insert(
                    '',
                    'end',
                    text='  暂无文件 - 点击上方按钮添加文件或文件夹',
                    values=('', '', '')
                )
            else:
                # 3. 构建并批量插入
                tree_structure = self._build_tree_structure(files)
                self._insert_tree_recursive('', tree_structure)
            
            # 4. 强制更新一次UI
            self.file_tree.update_idletasks()
            
        finally:
            # 5. 延迟恢复选择模式，确保UI完全更新
            self.after(10, self._restore_tree_state)
    
    def _restore_tree_state(self):
        """恢复树状态"""
        self.file_tree.configure(selectmode='browse')
        self._update_lock = False
    
    def _animate_loading(self):
        """加载动画"""
        if self._loading:
            current = self.loading_progress.get()
            if current >= 1.0:
                self.loading_progress.set(0)
            else:
                self.loading_progress.set(current + 0.05)
            
            self._loading_animation_id = self.after(50, self._animate_loading)
    
    def _show_loading(self, show: bool):
        """显示/隐藏加载指示器"""
        self._loading = show
        
        if show:
            self.loading_container.pack(side='right', padx=MD.PAD_M)
            self.loading_progress.set(0)
            self._animate_loading()
        else:
            if self._loading_animation_id:
                self.after_cancel(self._loading_animation_id)
                self._loading_animation_id = None
            self.loading_container.pack_forget()
    
    def refresh(self):
        """刷新显示"""
        self._filter_files()
        
        # 更新统计
        stats = self.file_handler.get_stats()
        self.stats_label.configure(
            text=f"📊 {stats['marked']}/{stats['total']} 个文件已选中  •  "
                 f"💾 共 {format_size(stats['size'])}  •  "
                 f"🔤 {stats['languages']} 种语言"
        )
    
    def set_update_callback(self, callback):
        """设置更新回调"""
        self.on_update_callback = callback

    def set_file_add_callback(self, callback):
        """设置文件添加回调"""
        self.on_file_add_callback = callback
# ui\components\__init__.py

```python
# UI组件包

# ui\widgets\material_card.py

```python
"""
简化卡片组件
"""

import customtkinter as ctk
from config.theme import MD

class Card(ctk.CTkFrame):
    """简化卡片"""

    def __init__(self, master, **kwargs):
        kwargs.setdefault('fg_color', MD.BG_SURFACE)
        kwargs.setdefault('corner_radius', MD.RADIUS)
        super().__init__(master, **kwargs)

class Btn(ctk.CTkButton):
    """简化按钮 - 3种变体"""

    def __init__(self, master, kind='normal', **kwargs):
        # kind: 'primary', 'danger', 'normal'
        if kind == 'primary':
            kwargs.update({
                'fg_color': MD.ACCENT_BLUE,
                'hover_color': MD.BG_ELEVATED,
                'text_color': '#FFFFFF'
            })
        elif kind == 'danger':
            kwargs.update({
                'fg_color': MD.ACCENT_RED,
                'hover_color': MD.BG_ELEVATED,
                'text_color': '#FFFFFF'
            })
        else:  # normal
            kwargs.update({
                'fg_color': 'transparent',
                'border_width': 1,
                'border_color': MD.BORDER,
                'hover_color': MD.BG_ELEVATED,
                'text_color': MD.TEXT_PRIMARY
            })

        kwargs.setdefault('corner_radius', MD.RADIUS)
        kwargs.setdefault('font', MD.FONT_UI)
        kwargs.setdefault('height', 28)

        super().__init__(master, **kwargs)
# ui\widgets\__init__.py

```python
# UI小部件包

# utils\helpers.py

```python
"""
辅助工具函数
"""

import os
from typing import Optional

def get_relative_path(file_path: str, base_path: Optional[str] = None) -> str:
    """获取相对路径"""
    if base_path is None:
        base_path = os.getcwd()
    
    try:
        return os.path.relpath(file_path, base_path)
    except ValueError:
        return file_path

def truncate_string(s: str, max_length: int, suffix: str = '...') -> str:
    """截断字符串"""
    if len(s) <= max_length:
        return s
    return s[:max_length - len(suffix)] + suffix

def validate_file_path(path: str) -> bool:
    """验证文件路径"""
    return os.path.isfile(path) and os.path.exists(path)

# utils\__init__.py

```python
# 工具函数包



---

## 转换统计

- 成功转换: **19** 个文件
- 总计处理: **19** 个文件
- 完成时间: 2025-10-14 19:07:50

---

文档生成完成
